<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Top Down Extraction Shooter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            height: 100vh;
            width: 100vw;
            background-color: #222;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Lighting effect canvas
        let lightingCanvas = null;
        let lightingCtx = null;

        function initLightingCanvas(width, height) {
            if (!lightingCanvas) {
                lightingCanvas = document.createElement('canvas');
                lightingCtx = lightingCanvas.getContext('2d');
            }
            lightingCanvas.width = width;
            lightingCanvas.height = height;
        }

        // Set canvas size to window size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initLightingCanvas(canvas.width, canvas.height);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Map dimensions (larger dungeon map)
        const mapWidth = 8600;
        const mapHeight = 6200;

        // Camera object
        const camera = {
            x: 0,
            y: 0
        };

        const playerSpawn = {
            x: mapWidth / 2,
            y: mapHeight / 2
        };

        // Player object
        const player = {
            x: playerSpawn.x,
            y: playerSpawn.y,
            width: 30,
            height: 30,
            speed: 2.4,
            velocityX: 0,
            velocityY: 0,
            color: '#00ff00',
            ammo: 10,
            maxAmmo: 10,
            fireCooldown: 0,
            isReloading: false,
            reloadTime: 0,
            maxReloadTime: 120, // frames for reload (2 seconds at 60fps)
            health: 100,
            maxHealth: 100,
            invulnerable: false,
            invulnerableTime: 0,
            hitTimer: 0,
            dashCooldown: 0,
            maxDashCooldown: 80,
            dashDistance: 130,
            dashFrames: 8,
            dashTimer: 0,
            dashVelocityX: 0,
            dashVelocityY: 0,
            meleeCooldown: 0,
            maxMeleeCooldown: 24,
            meleeRange: 85,
            meleeDamage: 2,
            meleeEffectTimer: 0,
            meleeDirX: 1,
            meleeDirY: 0,
            burnTimer: 0,
            burnTickTimer: 0,
            burnTickDamage: 0,
            burnVisualTimer: 0
        };

        // Walkable floor zones (everything outside is empty void)
        const walkableZones = [
            // Connected dungeon footprint (keeps dark void mainly on outer edges)
            { x: 1200, y: 980, width: 5750, height: 3150 },
            { x: 780, y: 1480, width: 1680, height: 3180 },
            { x: 6700, y: 1460, width: 1500, height: 2540 },
            { x: 2280, y: 3920, width: 4720, height: 980 },
            { x: 1860, y: 1040, width: 820, height: 620 }
        ];

        // Obstacles array - interior walls and cover
        const obstacles = [
            // Cage separators (top ring)
            { x: 2540, y: 1200, width: 80, height: 400 },
            { x: 2880, y: 1200, width: 80, height: 400 },
            { x: 3220, y: 1200, width: 80, height: 400 },
            { x: 4660, y: 1200, width: 80, height: 400 },
            { x: 5020, y: 1200, width: 80, height: 400 },
            { x: 5380, y: 1200, width: 80, height: 400 },

            // Central combat ring blockers
            { x: 3300, y: 2400, width: 120, height: 120 },
            { x: 3720, y: 2400, width: 120, height: 120 },
            { x: 4140, y: 2400, width: 120, height: 120 },
            { x: 4560, y: 2400, width: 120, height: 120 },
            { x: 3300, y: 2920, width: 120, height: 120 },
            { x: 4560, y: 2920, width: 120, height: 120 },

            // Midline room dividers
            { x: 3620, y: 3340, width: 90, height: 240 },
            { x: 3980, y: 3340, width: 90, height: 240 },
            { x: 4340, y: 3340, width: 90, height: 240 },
            { x: 4700, y: 3340, width: 90, height: 240 },

            // Left office / waiting room structure
            { x: 1120, y: 2460, width: 760, height: 80 },
            { x: 1120, y: 2800, width: 760, height: 80 },
            { x: 1480, y: 2540, width: 80, height: 260 },

            // Left lower storage structure
            { x: 980, y: 3980, width: 900, height: 80 },
            { x: 980, y: 4420, width: 900, height: 80 },
            { x: 1360, y: 4060, width: 80, height: 360 },

            // Right side cells / storage walls
            { x: 6400, y: 2560, width: 760, height: 80 },
            { x: 6400, y: 2940, width: 760, height: 80 },
            { x: 6760, y: 2640, width: 80, height: 300 },
            { x: 6400, y: 3340, width: 760, height: 80 },

            // Right monster lair blockers
            { x: 7600, y: 2760, width: 460, height: 100 },
            { x: 7600, y: 3340, width: 460, height: 100 },

            // Bottom hall pillars
            { x: 3000, y: 4100, width: 120, height: 120 },
            { x: 3560, y: 4100, width: 120, height: 120 },
            { x: 4120, y: 4100, width: 120, height: 120 },
            { x: 4680, y: 4100, width: 120, height: 120 },
            { x: 5240, y: 4100, width: 120, height: 120 }
        ];

        // Bullets array
        const bullets = [];
        const bulletTrailMin = 6;
        const bulletTrailMax = 14;
        const bulletTrailAlpha = 0.45;
        const weaponConfigs = {
            handgun: {
                id: 'handgun',
                name: 'Handgun',
                maxAmmo: 10,
                reloadFrames: 120,
                bulletSpeed: 10.5,
                bulletSize: 5,
                damage: 1,
                shotsPerTrigger: 1,
                spread: 0,
                fireCooldownFrames: 0
            },
            ar: {
                id: 'ar',
                name: 'AR',
                maxAmmo: 24,
                reloadFrames: 240,
                bulletSpeed: 12,
                bulletSize: 4,
                damage: 1,
                shotsPerTrigger: 1,
                spread: 0.39,
                fireCooldownFrames: 10
            },
            rifle: {
                id: 'rifle',
                name: 'Rifle',
                maxAmmo: 8,
                reloadFrames: 420,
                bulletSpeed: 45,
                bulletSize: 5,
                damage: 7,
                shotsPerTrigger: 1,
                spread: 0.03,
                fireCooldownFrames: 120,
                range: 2200
            },
            shotgun: {
                id: 'shotgun',
                name: 'Shotgun',
                maxAmmo: 6,
                reloadFrames: 150,
                bulletSpeed: 9,
                bulletSize: 4,
                damage: 0.7,
                shotsPerTrigger: 6,
                spread: 0.75,
                fireCooldownFrames: 75
            }
        };
        const enemyWeaponConfigs = {
            handgun: {
                id: 'handgun',
                bulletSpeed: 10,
                bulletSize: 4,
                damage: 8,
                shotsPerTrigger: 1,
                spread: 0.08,
                fireCooldownFrames: 50
            },
            ar: {
                id: 'ar',
                bulletSpeed: 11,
                bulletSize: 4,
                damage: 6,
                shotsPerTrigger: 1,
                spread: 0.16,
                fireCooldownFrames: 22
            },
            shotgun: {
                id: 'shotgun',
                bulletSpeed: 9.5,
                bulletSize: 4,
                damage: 3.5,
                shotsPerTrigger: 5,
                spread: 0.55,
                fireCooldownFrames: 65
            },
            rifle: {
                id: 'rifle',
                bulletSpeed: 13,
                bulletSize: 5,
                damage: 10,
                shotsPerTrigger: 1,
                spread: 0.07,
                fireCooldownFrames: 80
            },
            flameShotgun: {
                id: 'flameShotgun',
                bulletSpeed: 8.5,
                bulletSize: 5,
                damage: 2.8,
                shotsPerTrigger: 6,
                spread: 0.7,
                fireCooldownFrames: 55,
                appliesBurn: true,
                burnDamage: 2,
                burnDuration: 140
            },
            minigun: {
                id: 'minigun',
                bulletSpeed: 12.5,
                bulletSize: 4,
                damage: 3.8,
                shotsPerTrigger: 1,
                spread: 0.28,
                fireCooldownFrames: 4
            },
            sniper: {
                id: 'sniper',
                bulletSpeed: 16,
                bulletSize: 5,
                damage: 14,
                shotsPerTrigger: 1,
                spread: 0.02,
                fireCooldownFrames: 45
            }
        };
        let selectedWeaponId = 'handgun';

        // Enemy bullets array
        const enemyBullets = [];
        const enemyBulletSpeed = 9;
        const enemyBulletSize = 4;
        const hitscanEffects = [];
        const hitscanFlashFrames = 6;

        // Enemy factions
        const enemyFactions = [
            { id: 0, color: '#ff4d4d' },
            { id: 1, color: '#4dd2ff' },
            { id: 2, color: '#ffd24d' }
        ];
        const eliteFactionId = 99;
        const eliteColor = '#d16bff';
        const factionWander = enemyFactions.map(() => ({
            x: 0,
            y: 0,
            timer: 0
        }));

        // Visibility settings
        const visibilityRadius = 8000; // Large radius for light effect to cover whole map
        const visibilitySoftEdge = 160;

        // Hearing settings
        const hearingRadius = 900;

        // Enemy vision settings
        const enemySightRange = 1200;
        const enemyFovAngle = Math.PI * 0.4; // ~72 degrees
        const enemyConeLength = 280;
        const enemyTargetRange = 950;

        // Audio
        let audioContext = null;

        // Particles array for explosions
        const particles = [];

        // Enemies array
        const enemies = [];

        // Coins array
        const coins = [];

        // Noise system
        const noise = {
            x: playerSpawn.x,
            y: playerSpawn.y,
            value: 0,
            decay: 0.96,
            baseRadius: 120,
            maxRadius: 700
        };

        const screenShake = {
            intensity: 0,
            timer: 0,
            decay: 0.85
        };

        // Game state
        let gameState = 'playing'; // 'playing' or 'death'
        let isPaused = false;
        let difficulty = 1;
        let maxDifficulty = 20;
        let difficultyProgress = 0; // 0 to 100 for current level
        let difficultyIncreaseRate = 0.017; // Per frame (100% faster)
        let spawnTimer = 0;
        let money = 0;
        let enemiesKilled = 0;
        let runEnemiesKilled = 0;
        let runMoneyEarned = 0;
        
        // Upgrade system
        const upgrades = {
            damage: { level: 0 },
            moveSpeed: { level: 0 },
            fireSpeed: { level: 0 },
            reloadSpeed: { level: 0 }
        };

        function resetUpgradeLevels() {
            upgrades.damage.level = 0;
            upgrades.moveSpeed.level = 0;
            upgrades.fireSpeed.level = 0;
            upgrades.reloadSpeed.level = 0;
        }

        function loadTransientStateFromQuery() {
            const params = new URLSearchParams(window.location.search);

            const queryWeaponId = params.get('weapon');
            selectedWeaponId = (queryWeaponId && weaponConfigs[queryWeaponId]) ? queryWeaponId : 'handgun';

            const queryMoney = Number.parseInt(params.get('money') || '0', 10);
            money = Number.isFinite(queryMoney) ? Math.max(0, queryMoney) : 0;

            resetUpgradeLevels();
            const damageLevel = Number.parseInt(params.get('upgDamage') || '0', 10);
            const moveSpeedLevel = Number.parseInt(params.get('upgMoveSpeed') || '0', 10);
            const fireSpeedLevel = Number.parseInt(params.get('upgFireSpeed') || '0', 10);
            const reloadSpeedLevel = Number.parseInt(params.get('upgReloadSpeed') || '0', 10);
            upgrades.damage.level = Number.isFinite(damageLevel) ? Math.max(0, damageLevel) : 0;
            upgrades.moveSpeed.level = Number.isFinite(moveSpeedLevel) ? Math.max(0, moveSpeedLevel) : 0;
            upgrades.fireSpeed.level = Number.isFinite(fireSpeedLevel) ? Math.max(0, fireSpeedLevel) : 0;
            upgrades.reloadSpeed.level = Number.isFinite(reloadSpeedLevel) ? Math.max(0, reloadSpeedLevel) : 0;
        }

        function buildBaseStateQuery() {
            const params = new URLSearchParams();
            params.set('weapon', selectedWeaponId);
            params.set('money', String(Math.max(0, Math.floor(money))));
            params.set('upgDamage', String(Math.max(0, upgrades.damage.level)));
            params.set('upgMoveSpeed', String(Math.max(0, upgrades.moveSpeed.level)));
            params.set('upgFireSpeed', String(Math.max(0, upgrades.fireSpeed.level)));
            params.set('upgReloadSpeed', String(Math.max(0, upgrades.reloadSpeed.level)));
            return params.toString();
        }

        function spawnExtractDoor() {
            // Try to find a safe location for the door
            const doorWidth = extractDoor.width;
            const doorHeight = extractDoor.height;
            const minDistanceFromCenter = 800; // Must be far from player spawn
            const centerX = mapWidth / 2;
            const centerY = mapHeight / 2;

            for (let i = 0; i < 50; i++) {
                const candidate = getRandomWalkablePosition(doorWidth, doorHeight);
                const x = candidate.x;
                const y = candidate.y;

                // Check distance from center (player spawn)
                const distFromCenter = Math.hypot(x - centerX, y - centerY);
                if (distFromCenter < minDistanceFromCenter) {
                    continue;
                }

                // Check no obstacle collision (redundant but safe)
                if (checkObstacleCollision(x, y, doorWidth, doorHeight)) {
                    continue;
                }

                extractDoor.x = x;
                extractDoor.y = y;
                return;
            }

            // Fallback: place at any valid location
            const fallback = getRandomWalkablePosition(doorWidth, doorHeight);
            extractDoor.x = fallback.x;
            extractDoor.y = fallback.y;
        }

        function updateExtractDoor() {
            // Check if player is near and wants to interact
            const playerCenterX = player.x + player.width / 2;
            const playerCenterY = player.y + player.height / 2;
            const doorCenterX = extractDoor.x + extractDoor.width / 2;
            const doorCenterY = extractDoor.y + extractDoor.height / 2;
            const distance = Math.hypot(playerCenterX - doorCenterX, playerCenterY - doorCenterY);

            if (distance < extractDoor.interactDistance && (keys['e'] || keys['enter'])) {
                // Player interacts with door - extract and return to base
                extractPlayer();
            }
        }

        function extractPlayer() {
            // Extract successful - return to base with current state
            window.location.href = `base.html?${buildBaseStateQuery()}`;
        }

        function drawExtractDoor() {
            const x = extractDoor.x - camera.x;
            const y = extractDoor.y - camera.y;
            const centerX = x + extractDoor.width / 2;
            const centerY = y + extractDoor.height / 2;

            // Draw door
            ctx.fillStyle = extractDoor.color;
            ctx.fillRect(x, y, extractDoor.width, extractDoor.height);

            // Door border
            ctx.strokeStyle = '#ffff00';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, extractDoor.width, extractDoor.height);

            // Door label
            ctx.fillStyle = '#ffff00';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('EXIT', centerX, centerY);
        }
        
        function applyUpgradesToPlayer() {
            // Base speed: 2.4
            player.speed = 2.4 * (1 + upgrades.moveSpeed.level * 0.1);
            
            // Base melee damage: 2
            player.meleeDamage = 2 + upgrades.damage.level;
        }
        
        function applyUpgradesToWeapon(weapon) {
            // Apply damage upgrade
            weapon.damage = weapon.damage * (1 + upgrades.damage.level * 0.15);
            
            // Apply fire speed upgrade (reduce cooldown)
            weapon.fireCooldownFrames = Math.max(0, weapon.fireCooldownFrames - upgrades.fireSpeed.level * 2);
            
            // Apply reload speed upgrade (reduce reload time)
            weapon.reloadFrames = Math.max(30, weapon.reloadFrames - upgrades.reloadSpeed.level * 10);
        }
        
        // Death animation variables
        let deathTimer = 0;
        let deathMoneyCount = 0;
        let deathKillsCount = 0;
        let deathMoneyPenalty = 0; // money lost due to death (divided by 10)
        let continueButtonHover = false;

        // Extract door (DISABLED FOR TESTING)
        // const extractDoor = {
        //     x: 0,
        //     y: 0,
        //     width: 40,
        //     height: 40,
        //     color: '#ffaa00',
        //     interactDistance: 60
        // };

        function getSelectedWeapon() {
            const weapon = weaponConfigs[selectedWeaponId] || weaponConfigs.handgun;
            const upgraded = { ...weapon };
            applyUpgradesToWeapon(upgraded);
            return upgraded;
        }

        function applySelectedWeapon(loadAmmo = false) {
            const weapon = getSelectedWeapon();
            player.maxAmmo = weapon.maxAmmo;
            player.maxReloadTime = weapon.reloadFrames;
            if (loadAmmo) {
                player.ammo = player.maxAmmo;
            } else if (player.ammo > player.maxAmmo) {
                player.ammo = player.maxAmmo;
            }
            applyUpgradesToPlayer();
        }

        function getEnemyWeaponConfig(enemy) {
            return enemyWeaponConfigs[enemy.weaponId] || enemyWeaponConfigs.handgun;
        }

        function getEnemyAmmoProfile(weaponId) {
            if (!weaponId) {
                return { maxAmmo: 0, reloadFrames: 0 };
            }

            const fallbackMap = {
                sniper: 'rifle',
                minigun: 'ar',
                flameShotgun: 'shotgun'
            };

            const baseId = weaponConfigs[weaponId]
                ? weaponId
                : (fallbackMap[weaponId] || 'handgun');
            const baseWeapon = weaponConfigs[baseId] || weaponConfigs.handgun;
            return { maxAmmo: baseWeapon.maxAmmo, reloadFrames: baseWeapon.reloadFrames };
        }

        function chooseEnemyWeaponId() {
            const roll = Math.random();
            if (difficulty >= 12) {
                if (roll < 0.35) return 'ar';
                if (roll < 0.55) return 'rifle';
                if (roll < 0.75) return 'shotgun';
                return 'handgun';
            }
            if (difficulty >= 6) {
                if (roll < 0.3) return 'ar';
                if (roll < 0.42) return 'rifle';
                if (roll < 0.55) return 'shotgun';
                return 'handgun';
            }
            if (difficulty >= 3) {
                if (roll < 0.22) return 'ar';
                if (roll < 0.32) return 'rifle';
                if (roll < 0.42) return 'shotgun';
                return 'handgun';
            }
            return 'handgun';
        }

        function chooseEnemyVariant() {
            const roll = Math.random();
            if (difficulty >= 4 && roll < 0.05) {
                return 'special';
            }
            if (difficulty >= 3 && roll < 0.15) {
                return 'melee';
            }
            return 'ranged';
        }

        function chooseSpecialWeaponId() {
            const options = ['handgun', 'ar', 'rifle', 'shotgun'];
            return options[Math.floor(Math.random() * options.length)];
        }

        function chooseEliteVariant() {
            const roll = Math.random();
            if (roll < 0.36) {
                return 'eliteFlame';
            }
            if (roll < 0.72) {
                return 'eliteMinigun';
            }
            return 'eliteSniper';
        }

        function getEliteWeaponId(variant) {
            if (variant === 'eliteFlame') return 'flameShotgun';
            if (variant === 'eliteMinigun') return 'minigun';
            return 'sniper';
        }

        function tryPlayerShootAt(mapMouseX, mapMouseY) {
            if (gameState !== 'playing' || isPaused || player.isReloading || player.ammo <= 0 || player.fireCooldown > 0) {
                return false;
            }

            const weapon = getSelectedWeapon();
            const dx = mapMouseX - (player.x + player.width / 2);
            const dy = mapMouseY - (player.y + player.height / 2);
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance <= 0) {
                return false;
            }

            if (weapon.id === 'rifle') {
                performRifleHitscan(mapMouseX, mapMouseY, weapon);
            } else {
                const baseAngle = Math.atan2(dy, dx);
                for (let shot = 0; shot < weapon.shotsPerTrigger; shot++) {
                    const spreadOffset = (Math.random() - 0.5) * weapon.spread;
                    const angle = baseAngle + spreadOffset;
                    bullets.push({
                        x: player.x + player.width / 2,
                        y: player.y + player.height / 2,
                        velocityX: Math.cos(angle) * weapon.bulletSpeed,
                        velocityY: Math.sin(angle) * weapon.bulletSpeed,
                        size: weapon.bulletSize,
                        damage: weapon.damage,
                        color: '#ffff00',
                        trail: [],
                        trailMax: Math.max(bulletTrailMin, Math.min(bulletTrailMax, Math.round(weapon.bulletSpeed)))
                    });
                }
            }

            player.ammo--;
            player.fireCooldown = weapon.fireCooldownFrames || 0;
            addNoise(0.35);
            playGunshot(0);
            addScreenShake(6, 12);

            if (player.ammo <= 0) {
                player.isReloading = true;
                player.reloadTime = player.maxReloadTime;
            }

            return true;
        }

        function performRifleHitscan(mapMouseX, mapMouseY, weapon) {
            const originX = player.x + player.width / 2;
            const originY = player.y + player.height / 2;
            const dx = mapMouseX - originX;
            const dy = mapMouseY - originY;
            const distance = Math.hypot(dx, dy) || 1;
            const dirX = dx / distance;
            const dirY = dy / distance;
            const range = weapon.range || 2000;
            const endX = originX + dirX * range;
            const endY = originY + dirY * range;

            let closestIndex = -1;
            let closestDistance = range + 1;
            let hitX = endX;
            let hitY = endY;

            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const enemyCenterX = enemy.x + enemy.width / 2;
                const enemyCenterY = enemy.y + enemy.height / 2;
                const enemyDistance = Math.hypot(enemyCenterX - originX, enemyCenterY - originY);

                if (enemyDistance > range) {
                    continue;
                }

                if (!hasLineOfSight(originX, originY, enemyCenterX, enemyCenterY)) {
                    continue;
                }

                if (!lineIntersectsRect(originX, originY, endX, endY, enemy.x, enemy.y, enemy.width, enemy.height)) {
                    continue;
                }

                if (enemyDistance < closestDistance) {
                    closestDistance = enemyDistance;
                    closestIndex = i;
                    hitX = enemyCenterX;
                    hitY = enemyCenterY;
                }
            }

            addHitscanEffect(originX, originY, hitX, hitY);

            if (closestIndex >= 0) {
                const enemy = enemies[closestIndex];
                applyDamageToEnemy(enemy, weapon.damage);
                enemy.hitTimer = 10;
                createHitEffect(hitX, hitY, '#ff6666');
                playHitSound(closestDistance);
                if (enemy.health <= 0) {
                    killEnemy(closestIndex, true);
                }
            }
        }

        // Input handling
        const keys = {};
        const mouseButtons = {
            left: false
        };
        const mousePosition = {
            x: canvas.width / 2,
            y: canvas.height / 2
        };

        window.addEventListener('keydown', (e) => {
            initAudio();
            // Toggle pause on ESC (only during gameplay)
            if (e.key === 'Escape' && gameState === 'playing') {
                isPaused = !isPaused;
                return;
            }
            if (e.key === '`' && gameState === 'playing') {
                if (difficulty < maxDifficulty) {
                    difficulty++;
                    if (difficulty > maxDifficulty) {
                        difficulty = maxDifficulty;
                    }
                    difficultyProgress = 0;
                }
                return;
            }
            if (e.code === 'Space' && gameState === 'playing' && !isPaused) {
                performDash();
                e.preventDefault();
            }
            keys[e.key.toLowerCase()] = true;
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        // Mouse click to shoot
        window.addEventListener('mousedown', (e) => {
            initAudio();
            const rect = canvas.getBoundingClientRect();
            mousePosition.x = e.clientX - rect.left;
            mousePosition.y = e.clientY - rect.top;

            // Handle continue button on death screen
            const explosionDuration = 200;
            if (gameState === 'death' && deathTimer > explosionDuration + 240 && deathMoneyCount >= runMoneyEarned && deathKillsCount >= runEnemiesKilled) {
                const buttonWidth = 200;
                const buttonHeight = 50;
                const buttonX = canvas.width / 2 - buttonWidth / 2;
                const buttonY = canvas.height / 2 + 200;

                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                if (mouseX >= buttonX && mouseX <= buttonX + buttonWidth &&
                    mouseY >= buttonY && mouseY <= buttonY + buttonHeight) {
                    window.location.href = `base.html?${buildBaseStateQuery()}`;
                    return;
                }
            }

            if (gameState === 'playing' && !isPaused) {
                if (e.button === 2) {
                    performMeleeAttack();
                    return;
                }

                if (e.button !== 0) {
                    return;
                }

                mouseButtons.left = true;
            }
            
            if (gameState !== 'playing' || e.button !== 0) {
                return;
            }

            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            tryPlayerShootAt(mouseX + camera.x, mouseY + camera.y);
        });

        window.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                mouseButtons.left = false;
            }
        });

        // Prevent browser context menu on right-click
        window.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        // Mouse move for button hover
        window.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mousePosition.x = e.clientX - rect.left;
            mousePosition.y = e.clientY - rect.top;

            const explosionDuration = 200;
            if (gameState === 'death' && deathTimer > explosionDuration + 240) {
                const buttonWidth = 200;
                const buttonHeight = 50;
                const buttonX = canvas.width / 2 - buttonWidth / 2;
                const buttonY = canvas.height / 2 + 200;

                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                continueButtonHover = mouseX >= buttonX && mouseX <= buttonX + buttonWidth &&
                                     mouseY >= buttonY && mouseY <= buttonY + buttonHeight;
            } else {
                continueButtonHover = false;
            }
        });

        function performDash() {
            if (player.dashCooldown > 0 || player.dashTimer > 0) {
                return;
            }

            let dirX = 0;
            let dirY = 0;

            if (keys['w']) dirY -= 1;
            if (keys['s']) dirY += 1;
            if (keys['a']) dirX -= 1;
            if (keys['d']) dirX += 1;

            if (dirX === 0 && dirY === 0) {
                const playerCenterX = player.x + player.width / 2;
                const playerCenterY = player.y + player.height / 2;
                dirX = (mousePosition.x + camera.x) - playerCenterX;
                dirY = (mousePosition.y + camera.y) - playerCenterY;
            }

            const length = Math.hypot(dirX, dirY);
            if (length === 0) {
                return;
            }

            const normalizedX = dirX / length;
            const normalizedY = dirY / length;
            player.dashVelocityX = normalizedX * (player.dashDistance / player.dashFrames);
            player.dashVelocityY = normalizedY * (player.dashDistance / player.dashFrames);
            player.dashTimer = player.dashFrames;
            player.dashCooldown = player.maxDashCooldown;
            addNoise(0.08);
        }

        function performMeleeAttack() {
            if (player.meleeCooldown > 0) {
                return;
            }

            player.meleeCooldown = player.maxMeleeCooldown;
            player.meleeEffectTimer = 8;

            const playerCenterX = player.x + player.width / 2;
            const playerCenterY = player.y + player.height / 2;
            let dirX = (mousePosition.x + camera.x) - playerCenterX;
            let dirY = (mousePosition.y + camera.y) - playerCenterY;
            const dirLength = Math.hypot(dirX, dirY) || 1;
            dirX /= dirLength;
            dirY /= dirLength;
            player.meleeDirX = dirX;
            player.meleeDirY = dirY;

            addNoise(0.1);

            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const enemyCenterX = enemy.x + enemy.width / 2;
                const enemyCenterY = enemy.y + enemy.height / 2;
                const toEnemyX = enemyCenterX - playerCenterX;
                const toEnemyY = enemyCenterY - playerCenterY;
                const distance = Math.hypot(toEnemyX, toEnemyY);

                if (distance > player.meleeRange) {
                    continue;
                }

                const normalizedToEnemyX = toEnemyX / (distance || 1);
                const normalizedToEnemyY = toEnemyY / (distance || 1);
                const dot = normalizedToEnemyX * dirX + normalizedToEnemyY * dirY;

                if (dot < 0.2) {
                    continue;
                }

                applyDamageToEnemy(enemy, player.meleeDamage);
                enemy.hitTimer = 10;
                createHitEffect(enemyCenterX, enemyCenterY, '#ffeeaa');
                playHitSound(distance);

                if (enemy.health <= 0) {
                    killEnemy(i, true);
                }
            }
        }
        // Update player position
        function updatePlayer() {
            player.velocityX = 0;
            player.velocityY = 0;

            if (player.dashCooldown > 0) {
                player.dashCooldown--;
            }

            if (player.meleeCooldown > 0) {
                player.meleeCooldown--;
            }

            if (player.meleeEffectTimer > 0) {
                player.meleeEffectTimer--;
            }

            if (player.fireCooldown > 0) {
                player.fireCooldown--;
            }

            if (player.burnTimer > 0) {
                player.burnTimer--;
                if (player.burnVisualTimer > 0) {
                    player.burnVisualTimer--;
                }
                if (player.burnTickTimer > 0) {
                    player.burnTickTimer--;
                }
                if (player.burnTickTimer <= 0) {
                    player.burnTickTimer = 18;
                    player.health -= player.burnTickDamage;
                    player.hitTimer = 6;
                    createHitEffect(player.x + player.width / 2, player.y + player.height / 2, '#ff9933');
                    if (player.health <= 0) {
                        triggerPlayerDeath();
                        return;
                    }
                }
            } else {
                player.burnTickDamage = 0;
                player.burnTickTimer = 0;
                player.burnVisualTimer = 0;
            }

            if (mouseButtons.left && selectedWeaponId === 'ar') {
                tryPlayerShootAt(mousePosition.x + camera.x, mousePosition.y + camera.y);
            }

            let inputX = 0;
            let inputY = 0;

            if (keys['w']) {
                inputY -= 1;
            }
            if (keys['s']) {
                inputY += 1;
            }
            if (keys['a']) {
                inputX -= 1;
            }
            if (keys['d']) {
                inputX += 1;
            }

            if (inputX !== 0 || inputY !== 0) {
                const length = Math.hypot(inputX, inputY);
                player.velocityX = (inputX / length) * player.speed;
                player.velocityY = (inputY / length) * player.speed;
                addNoise(0.015);
            }

            // Manual reload with R key
            if (keys['r'] && !player.isReloading && player.ammo < player.maxAmmo) {
                player.isReloading = true;
                player.reloadTime = player.maxReloadTime;
            }

            // Helper function to check collision
            function checkCollision(x, y) {
                return checkObstacleCollision(x, y, player.width, player.height);
            }

            if (player.dashTimer > 0) {
                let dashNewX = player.x + player.dashVelocityX;
                if (!checkCollision(dashNewX, player.y)) {
                    player.x = dashNewX;
                }

                let dashNewY = player.y + player.dashVelocityY;
                if (!checkCollision(player.x, dashNewY)) {
                    player.y = dashNewY;
                }
                player.dashTimer--;
            } else {
                // Try to move horizontally
                let newX = player.x + player.velocityX;
                if (!checkCollision(newX, player.y)) {
                    player.x = newX;
                }

                // Try to move vertically
                let newY = player.y + player.velocityY;
                if (!checkCollision(player.x, newY)) {
                    player.y = newY;
                }
            }

            // Keep player in bounds of map
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > mapWidth) player.x = mapWidth - player.width;
            if (player.y < 0) player.y = 0;
            if (player.y + player.height > mapHeight) player.y = mapHeight - player.height;

            // Update reload
            if (player.isReloading) {
                player.reloadTime--;
                if (player.reloadTime <= 0) {
                    player.isReloading = false;
                    player.ammo = player.maxAmmo;
                }
            }

            if (player.hitTimer > 0) {
                player.hitTimer--;
            }

            // Update camera to follow player (keep player centered on screen)
            camera.x = player.x - canvas.width / 2 + player.width / 2;
            camera.y = player.y - canvas.height / 2 + player.height / 2;

            // Clamp camera to map bounds
            if (camera.x < 0) camera.x = 0;
            if (camera.x + canvas.width > mapWidth) camera.x = mapWidth - canvas.width;
            if (camera.y < 0) camera.y = 0;
            if (camera.y + canvas.height > mapHeight) camera.y = mapHeight - canvas.height;
        }

        function ensureBulletTrail(bullet) {
            if (!bullet.trail) {
                bullet.trail = [];
            }
            if (!bullet.trailMax) {
                const speed = Math.hypot(bullet.velocityX || 0, bullet.velocityY || 0) || 1;
                bullet.trailMax = Math.max(bulletTrailMin, Math.min(bulletTrailMax, Math.round(speed)));
            }
        }

        function pushBulletTrail(bullet) {
            ensureBulletTrail(bullet);
            bullet.trail.push({ x: bullet.x, y: bullet.y });
            if (bullet.trail.length > bullet.trailMax) {
                bullet.trail.shift();
            }
        }

        function drawBulletTrail(bullet) {
            if (!bullet.trail || bullet.trail.length < 2) {
                return;
            }

            ctx.save();
            ctx.strokeStyle = bullet.color;
            for (let i = 1; i < bullet.trail.length; i++) {
                const t = i / bullet.trail.length;
                ctx.globalAlpha = bulletTrailAlpha * t;
                ctx.lineWidth = Math.max(1, bullet.size * (0.6 + t));
                ctx.beginPath();
                ctx.moveTo(bullet.trail[i - 1].x - camera.x, bullet.trail[i - 1].y - camera.y);
                ctx.lineTo(bullet.trail[i].x - camera.x, bullet.trail[i].y - camera.y);
                ctx.stroke();
            }
            ctx.restore();
        }

        function addHitscanEffect(x1, y1, x2, y2) {
            hitscanEffects.push({
                x1,
                y1,
                x2,
                y2,
                life: hitscanFlashFrames,
                maxLife: hitscanFlashFrames
            });
        }

        function updateHitscanEffects() {
            for (let i = hitscanEffects.length - 1; i >= 0; i--) {
                hitscanEffects[i].life--;
                if (hitscanEffects[i].life <= 0) {
                    hitscanEffects.splice(i, 1);
                }
            }
        }

        function drawHitscanEffects() {
            for (let effect of hitscanEffects) {
                const t = effect.life / effect.maxLife;
                const startX = effect.x1 - camera.x;
                const startY = effect.y1 - camera.y;
                const endX = effect.x2 - camera.x;
                const endY = effect.y2 - camera.y;

                ctx.save();
                ctx.globalAlpha = 0.35 * t;
                ctx.strokeStyle = '#ffdd88';
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();

                ctx.globalAlpha = 0.85 * t;
                ctx.strokeStyle = '#fff4cc';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
                ctx.restore();
            }
        }

        // Update bullets
        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].x += bullets[i].velocityX;
                bullets[i].y += bullets[i].velocityY;
                pushBulletTrail(bullets[i]);

                // Check collision with obstacles
                let hitObstacle = false;
                for (let obstacle of obstacles) {
                    if (bullets[i].x > obstacle.x && 
                        bullets[i].x < obstacle.x + obstacle.width &&
                        bullets[i].y > obstacle.y && 
                        bullets[i].y < obstacle.y + obstacle.height) {
                        hitObstacle = true;
                        // Create explosion on hit
                        createExplosion(bullets[i].x, bullets[i].y);
                        break;
                    }
                }

                // Check if bullet hit map boundaries or empty void
                let hitWall = bullets[i].x < 0 || bullets[i].x > mapWidth ||
                    bullets[i].y < 0 || bullets[i].y > mapHeight ||
                    !isPointInWalkableArea(bullets[i].x, bullets[i].y);

                if (hitWall) {
                    // Create explosion on wall hit
                    createExplosion(bullets[i].x, bullets[i].y);
                }

                // Remove bullets that go off map or hit obstacles
                if (hitObstacle || hitWall) {
                    bullets.splice(i, 1);
                }
            }
        }

        // Update enemy bullets
        function updateEnemyBullets() {
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const bullet = enemyBullets[i];
                bullet.x += bullet.velocityX;
                bullet.y += bullet.velocityY;
                pushBulletTrail(bullet);

                // Check collision with obstacles
                let hitObstacle = false;
                for (let obstacle of obstacles) {
                    if (bullet.x > obstacle.x &&
                        bullet.x < obstacle.x + obstacle.width &&
                        bullet.y > obstacle.y &&
                        bullet.y < obstacle.y + obstacle.height) {
                        hitObstacle = true;
                        createExplosion(bullet.x, bullet.y);
                        break;
                    }
                }

                // Check if bullet hit map boundaries or empty void
                let hitWall = bullet.x < 0 || bullet.x > mapWidth || bullet.y < 0 || bullet.y > mapHeight || !isPointInWalkableArea(bullet.x, bullet.y);

                // Check collision with player
                if (!hitObstacle && !hitWall &&
                    bullet.x > player.x &&
                    bullet.x < player.x + player.width &&
                    bullet.y > player.y &&
                    bullet.y < player.y + player.height) {
                    applyPlayerDamage(bullet.damage);
                    if (bullet.appliesBurn) {
                        applyBurnToPlayer(bullet.burnDamage || 1, bullet.burnDuration || 120);
                    }
                    enemyBullets.splice(i, 1);
                    continue;
                }

                // Check collision with enemies of other factions
                if (!hitObstacle && !hitWall) {
                    let hitEnemy = false;
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const enemy = enemies[j];
                        if (enemy.faction === bullet.faction) continue;
                        if (isEliteEnemy(enemy) || bullet.sourceElite) continue;
                        if (bullet.x > enemy.x &&
                            bullet.x < enemy.x + enemy.width &&
                            bullet.y > enemy.y &&
                            bullet.y < enemy.y + enemy.height) {
                            applyDamageToEnemy(enemy, bullet.damage * 0.35);
                            enemy.hitTimer = 10;
                            createHitEffect(bullet.x, bullet.y, '#ff6666');
                            const playerDistance = Math.hypot(bullet.x - (player.x + player.width / 2), bullet.y - (player.y + player.height / 2));
                            playHitSound(playerDistance);
                            createExplosion(bullet.x, bullet.y);
                            hitEnemy = true;

                            if (enemy.health <= 0) {
                                killEnemy(j, false);
                            }
                            break;
                        }
                    }
                    if (hitEnemy) {
                        enemyBullets.splice(i, 1);
                        continue;
                    }
                }

                // Remove bullets that go off map or hit obstacles
                if (hitObstacle || hitWall) {
                    enemyBullets.splice(i, 1);
                }
            }
        }

        // Create explosion effect
        function createExplosion(x, y) {
            const particleCount = 8;
            for (let i = 0; i < particleCount; i++) {
                const angle = (i / particleCount) * Math.PI * 2;
                const speed = 3 + Math.random() * 2;
                particles.push({
                    x: x,
                    y: y,
                    velocityX: Math.cos(angle) * speed,
                    velocityY: Math.sin(angle) * speed,
                    life: 20,
                    maxLife: 20,
                    size: 3 + Math.random() * 2,
                    color: '#ff6600'
                });
            }
        }

        // Update particles
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].x += particles[i].velocityX;
                particles[i].y += particles[i].velocityY;
                particles[i].life--;

                if (particles[i].life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function clamp(value, min, max) {
            return Math.max(min, Math.min(max, value));
        }

        function addNoise(amount) {
            noise.value = clamp(noise.value + amount, 0, 1);
            noise.x = player.x + player.width / 2;
            noise.y = player.y + player.height / 2;
        }

        function updateNoise() {
            if (noise.value > 0) {
                noise.value *= noise.decay;
                if (noise.value < 0.005) {
                    noise.value = 0;
                }
            }
        }

        function addScreenShake(intensity, duration) {
            screenShake.intensity = Math.max(screenShake.intensity, intensity);
            screenShake.timer = Math.max(screenShake.timer, duration);
        }

        function updateScreenShake() {
            if (screenShake.timer > 0) {
                screenShake.timer--;
                screenShake.intensity *= screenShake.decay;
                if (screenShake.timer <= 0 || screenShake.intensity < 0.1) {
                    screenShake.timer = 0;
                    screenShake.intensity = 0;
                }
            }

            if (screenShake.intensity <= 0) {
                return { x: 0, y: 0 };
            }

            const angle = Math.random() * Math.PI * 2;
            const magnitude = Math.random() * screenShake.intensity;
            return {
                x: Math.cos(angle) * magnitude,
                y: Math.sin(angle) * magnitude
            };
        }

        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        function playGunshot(distance) {
            if (!audioContext) return;
            const volume = clamp(1 - distance / hearingRadius, 0, 1);
            if (volume <= 0) return;

            const now = audioContext.currentTime;
            const gain = audioContext.createGain();
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(0.35 * volume, now + 0.005);
            gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.2);

            const osc = audioContext.createOscillator();
            osc.type = 'square';
            osc.frequency.setValueAtTime(140, now);
            osc.frequency.exponentialRampToValueAtTime(60, now + 0.08);

            const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.2, audioContext.sampleRate);
            const data = noiseBuffer.getChannelData(0);
            for (let i = 0; i < data.length; i++) {
                data[i] = (Math.random() * 2 - 1) * 0.6;
            }
            const noiseSource = audioContext.createBufferSource();
            noiseSource.buffer = noiseBuffer;

            const filter = audioContext.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(1200, now);
            filter.frequency.exponentialRampToValueAtTime(400, now + 0.12);

            osc.connect(filter);
            noiseSource.connect(filter);
            filter.connect(gain);
            gain.connect(audioContext.destination);

            osc.start(now);
            noiseSource.start(now);
            osc.stop(now + 0.2);
            noiseSource.stop(now + 0.2);
        }

        function playHitSound(distance) {
            if (!audioContext) return;
            const volume = clamp(1 - distance / hearingRadius, 0, 1);
            if (volume <= 0) return;

            const now = audioContext.currentTime;
            const gain = audioContext.createGain();
            gain.gain.setValueAtTime(0.2 * volume, now);
            gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.12);

            const osc = audioContext.createOscillator();
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(200, now);
            osc.frequency.exponentialRampToValueAtTime(90, now + 0.1);

            osc.connect(gain);
            gain.connect(audioContext.destination);
            osc.start(now);
            osc.stop(now + 0.12);
        }

        function createHitEffect(x, y, color) {
            const particleCount = 6;
            for (let i = 0; i < particleCount; i++) {
                const angle = (i / particleCount) * Math.PI * 2;
                const speed = 1.5 + Math.random() * 2;
                particles.push({
                    x: x,
                    y: y,
                    velocityX: Math.cos(angle) * speed,
                    velocityY: Math.sin(angle) * speed,
                    life: 14,
                    maxLife: 14,
                    size: 2 + Math.random() * 2,
                    color: color
                });
            }
        }

        function rectsIntersect(ax, ay, aw, ah, bx, by, bw, bh) {
            return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
        }

        function isPointInWalkableArea(x, y) {
            for (let zone of walkableZones) {
                if (x >= zone.x && x <= zone.x + zone.width && y >= zone.y && y <= zone.y + zone.height) {
                    return true;
                }
            }
            return false;
        }

        function isRectInWalkableArea(x, y, width, height) {
            const samplePoints = [
                { x, y },
                { x: x + width, y },
                { x, y: y + height },
                { x: x + width, y: y + height },
                { x: x + width / 2, y: y + height / 2 }
            ];

            for (let point of samplePoints) {
                if (!isPointInWalkableArea(point.x, point.y)) {
                    return false;
                }
            }

            return true;
        }

        function checkObstacleCollision(x, y, width, height) {
            if (x < 0 || y < 0 || x + width > mapWidth || y + height > mapHeight) {
                return true;
            }

            if (!isRectInWalkableArea(x, y, width, height)) {
                return true;
            }

            for (let obstacle of obstacles) {
                if (rectsIntersect(x, y, width, height, obstacle.x, obstacle.y, obstacle.width, obstacle.height)) {
                    return true;
                }
            }
            return false;
        }

        function moveEntityWithCollisions(entity, velocityX, velocityY) {
            let newX = entity.x + velocityX;
            if (!checkObstacleCollision(newX, entity.y, entity.width, entity.height)) {
                entity.x = newX;
            }

            let newY = entity.y + velocityY;
            if (!checkObstacleCollision(entity.x, newY, entity.width, entity.height)) {
                entity.y = newY;
            }

            entity.x = clamp(entity.x, 0, mapWidth - entity.width);
            entity.y = clamp(entity.y, 0, mapHeight - entity.height);
        }

        function tryMoveEntity(entity, velocityX, velocityY) {
            const newX = entity.x + velocityX;
            const newY = entity.y + velocityY;
            if (!checkObstacleCollision(newX, newY, entity.width, entity.height)) {
                entity.x = newX;
                entity.y = newY;
                entity.x = clamp(entity.x, 0, mapWidth - entity.width);
                entity.y = clamp(entity.y, 0, mapHeight - entity.height);
                return true;
            }
            return false;
        }

        function moveTowardWithAvoidance(entity, targetX, targetY, speed) {
            const centerX = entity.x + entity.width / 2;
            const centerY = entity.y + entity.height / 2;
            const dx = targetX - centerX;
            const dy = targetY - centerY;
            const distance = Math.hypot(dx, dy) || 1;
            const vx = (dx / distance) * speed;
            const vy = (dy / distance) * speed;

            if (tryMoveEntity(entity, vx, vy)) {
                return;
            }

            if (Math.abs(vx) > Math.abs(vy)) {
                if (tryMoveEntity(entity, vx, 0)) return;
                if (tryMoveEntity(entity, 0, vy)) return;
            } else {
                if (tryMoveEntity(entity, 0, vy)) return;
                if (tryMoveEntity(entity, vx, 0)) return;
            }

            const perpX = -vy;
            const perpY = vx;
            const perpLen = Math.hypot(perpX, perpY) || 1;
            const p1x = (perpX / perpLen) * speed;
            const p1y = (perpY / perpLen) * speed;
            const p2x = -p1x;
            const p2y = -p1y;

            const dist1 = Math.hypot((entity.x + p1x) - targetX, (entity.y + p1y) - targetY);
            const dist2 = Math.hypot((entity.x + p2x) - targetX, (entity.y + p2y) - targetY);

            if (dist1 <= dist2) {
                if (tryMoveEntity(entity, p1x, p1y)) return;
                tryMoveEntity(entity, p2x, p2y);
            } else {
                if (tryMoveEntity(entity, p2x, p2y)) return;
                tryMoveEntity(entity, p1x, p1y);
            }
        }

        function chooseWallFollowDirection(entity, targetX, targetY, speed) {
            const centerX = entity.x + entity.width / 2;
            const centerY = entity.y + entity.height / 2;
            const dx = targetX - centerX;
            const dy = targetY - centerY;
            const distance = Math.hypot(dx, dy) || 1;

            const perp1X = -dy / distance;
            const perp1Y = dx / distance;
            const perp2X = -perp1X;
            const perp2Y = -perp1Y;

            const step1X = perp1X * speed;
            const step1Y = perp1Y * speed;
            const step2X = perp2X * speed;
            const step2Y = perp2Y * speed;

            const can1 = !checkObstacleCollision(entity.x + step1X, entity.y + step1Y, entity.width, entity.height);
            const can2 = !checkObstacleCollision(entity.x + step2X, entity.y + step2Y, entity.width, entity.height);

            if (!can1 && !can2) {
                return { x: 0, y: 0 };
            }

            if (can1 && !can2) return { x: perp1X, y: perp1Y };
            if (!can1 && can2) return { x: perp2X, y: perp2Y };

            const dist1 = Math.hypot((centerX + step1X) - targetX, (centerY + step1Y) - targetY);
            const dist2 = Math.hypot((centerX + step2X) - targetX, (centerY + step2Y) - targetY);
            return dist1 <= dist2 ? { x: perp1X, y: perp1Y } : { x: perp2X, y: perp2Y };
        }

        function moveAlongWall(entity, targetX, targetY, speed) {
            if (entity.wallFollowTimer <= 0 || (entity.wallFollowDirX === 0 && entity.wallFollowDirY === 0)) {
                const dir = chooseWallFollowDirection(entity, targetX, targetY, speed);
                entity.wallFollowDirX = dir.x;
                entity.wallFollowDirY = dir.y;
                entity.wallFollowTimer = 90;
            }

            if (entity.wallFollowDirX === 0 && entity.wallFollowDirY === 0) {
                return;
            }

            const stepX = entity.wallFollowDirX * speed;
            const stepY = entity.wallFollowDirY * speed;
            if (!tryMoveEntity(entity, stepX, stepY)) {
                entity.wallFollowDirX = -entity.wallFollowDirX;
                entity.wallFollowDirY = -entity.wallFollowDirY;
                tryMoveEntity(entity, entity.wallFollowDirX * speed, entity.wallFollowDirY * speed);
            }

            entity.wallFollowTimer--;
        }

        function distancePointToSegment(px, py, ax, ay, bx, by) {
            const dx = bx - ax;
            const dy = by - ay;
            if (dx === 0 && dy === 0) {
                return Math.hypot(px - ax, py - ay);
            }
            const t = clamp(((px - ax) * dx + (py - ay) * dy) / (dx * dx + dy * dy), 0, 1);
            const closestX = ax + t * dx;
            const closestY = ay + t * dy;
            return Math.hypot(px - closestX, py - closestY);
        }

        function lineIntersectsRect(ax, ay, bx, by, rx, ry, rw, rh) {
            const left = rx;
            const right = rx + rw;
            const top = ry;
            const bottom = ry + rh;

            const dx = bx - ax;
            const dy = by - ay;

            let t0 = 0;
            let t1 = 1;

            const p = [-dx, dx, -dy, dy];
            const q = [ax - left, right - ax, ay - top, bottom - ay];

            for (let i = 0; i < 4; i++) {
                if (p[i] === 0) {
                    if (q[i] < 0) return false;
                } else {
                    const t = q[i] / p[i];
                    if (p[i] < 0) {
                        if (t > t1) return false;
                        if (t > t0) t0 = t;
                    } else {
                        if (t < t0) return false;
                        if (t < t1) t1 = t;
                    }
                }
            }

            return true;
        }

        function hasLineOfSight(ax, ay, bx, by) {
            const samples = 28;
            for (let i = 0; i <= samples; i++) {
                const t = i / samples;
                const px = ax + (bx - ax) * t;
                const py = ay + (by - ay) * t;
                if (!isPointInWalkableArea(px, py)) {
                    return false;
                }
            }

            for (let obstacle of obstacles) {
                if (lineIntersectsRect(ax, ay, bx, by, obstacle.x, obstacle.y, obstacle.width, obstacle.height)) {
                    return false;
                }
            }
            return true;
        }

        function normalizeAngle(angle) {
            let normalized = angle % (Math.PI * 2);
            if (normalized < -Math.PI) normalized += Math.PI * 2;
            if (normalized > Math.PI) normalized -= Math.PI * 2;
            return normalized;
        }

        function angleDelta(a, b) {
            return normalizeAngle(a - b);
        }

        function lerpAngle(current, target, t) {
            const delta = angleDelta(target, current);
            return normalizeAngle(current + delta * t);
        }

        function isInEnemyFov(enemy, targetX, targetY) {
            const centerX = enemy.x + enemy.width / 2;
            const centerY = enemy.y + enemy.height / 2;
            const dx = targetX - centerX;
            const dy = targetY - centerY;
            const distance = Math.hypot(dx, dy);
            if (distance > enemySightRange) {
                return false;
            }

            const targetAngle = Math.atan2(dy, dx);
            const delta = Math.abs(angleDelta(targetAngle, enemy.facingAngle || 0));
            return delta <= enemyFovAngle * 0.5;
        }

        function canEnemySeeTarget(enemy, targetX, targetY) {
            if (!isInEnemyFov(enemy, targetX, targetY)) {
                return false;
            }
            return hasLineOfSight(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, targetX, targetY);
        }

        function raySegmentIntersection(ox, oy, dx, dy, x1, y1, x2, y2) {
            const rdx = dx;
            const rdy = dy;
            const sdx = x2 - x1;
            const sdy = y2 - y1;
            const rxs = rdx * sdy - rdy * sdx;

            if (rxs === 0) return null;

            const qpx = x1 - ox;
            const qpy = y1 - oy;
            const t = (qpx * sdy - qpy * sdx) / rxs;
            const u = (qpx * rdy - qpy * rdx) / rxs;

            if (t >= 0 && u >= 0 && u <= 1) {
                return { x: ox + rdx * t, y: oy + rdy * t, t };
            }
            return null;
        }

        function getVisibilityPolygon(originX, originY, radius) {
            const angles = [];
            const epsilon = 0.00005;
            const occluderPadding = 1;

            for (let a = 0; a < Math.PI * 2; a += Math.PI / 180) {
                angles.push(a);
            }

            for (let obstacle of obstacles) {
                const padded = {
                    x: obstacle.x - occluderPadding,
                    y: obstacle.y - occluderPadding,
                    width: obstacle.width + occluderPadding * 2,
                    height: obstacle.height + occluderPadding * 2
                };
                const corners = [
                    { x: padded.x, y: padded.y },
                    { x: padded.x + padded.width, y: padded.y },
                    { x: padded.x + padded.width, y: padded.y + padded.height },
                    { x: padded.x, y: padded.y + padded.height }
                ];

                for (let corner of corners) {
                    const dist = Math.hypot(corner.x - originX, corner.y - originY);
                    if (dist <= radius + 100) {
                        const angle = Math.atan2(corner.y - originY, corner.x - originX);
                        angles.push(angle - epsilon, angle - epsilon / 2, angle, angle + epsilon / 2, angle + epsilon);
                    }
                }
            }

            const segments = [];
            for (let obstacle of obstacles) {
                const padded = {
                    x: obstacle.x - occluderPadding,
                    y: obstacle.y - occluderPadding,
                    width: obstacle.width + occluderPadding * 2,
                    height: obstacle.height + occluderPadding * 2
                };
                segments.push(
                    { x1: padded.x, y1: padded.y, x2: padded.x + padded.width, y2: padded.y },
                    { x1: padded.x + padded.width, y1: padded.y, x2: padded.x + padded.width, y2: padded.y + padded.height },
                    { x1: padded.x + padded.width, y1: padded.y + padded.height, x2: padded.x, y2: padded.y + padded.height },
                    { x1: padded.x, y1: padded.y + padded.height, x2: padded.x, y2: padded.y }
                );
            }

            segments.push(
                { x1: 0, y1: 0, x2: mapWidth, y2: 0 },
                { x1: mapWidth, y1: 0, x2: mapWidth, y2: mapHeight },
                { x1: mapWidth, y1: mapHeight, x2: 0, y2: mapHeight },
                { x1: 0, y1: mapHeight, x2: 0, y2: 0 }
            );

            const points = [];
            for (let angle of angles) {
                const dx = Math.cos(angle);
                const dy = Math.sin(angle);
                let closestT = radius;
                let closest = { x: originX + dx * radius, y: originY + dy * radius, t: radius };

                for (let seg of segments) {
                    const hit = raySegmentIntersection(originX, originY, dx, dy, seg.x1, seg.y1, seg.x2, seg.y2);
                    if (hit && hit.t > 0.01 && hit.t < closestT) {
                        closestT = hit.t;
                        closest = hit;
                    }
                }
                points.push({ x: closest.x, y: closest.y, angle });
            }

            points.sort((a, b) => a.angle - b.angle);
            return points;
        }

        function drawLightingEffect() {
            const playerCenterX = player.x + player.width / 2;
            const playerCenterY = player.y + player.height / 2;
            
            // Draw shadows for each obstacle
            ctx.fillStyle = '#000000';
            
            for (let obstacle of obstacles) {
                // Get obstacle corners
                const corners = [
                    { x: obstacle.x, y: obstacle.y },
                    { x: obstacle.x + obstacle.width, y: obstacle.y },
                    { x: obstacle.x + obstacle.width, y: obstacle.y + obstacle.height },
                    { x: obstacle.x, y: obstacle.y + obstacle.height }
                ];
                
                // Find which edges face away from player
                const edges = [
                    { p1: corners[0], p2: corners[1] }, // top
                    { p1: corners[1], p2: corners[2] }, // right
                    { p1: corners[2], p2: corners[3] }, // bottom
                    { p1: corners[3], p2: corners[0] }  // left
                ];
                
                for (let edge of edges) {
                    // Calculate edge midpoint
                    const midX = (edge.p1.x + edge.p2.x) / 2;
                    const midY = (edge.p1.y + edge.p2.y) / 2;
                    
                    // Vector from player to edge midpoint
                    const dx = midX - playerCenterX;
                    const dy = midY - playerCenterY;
                    
                    // Edge normal (perpendicular to edge)
                    const edgeDx = edge.p2.x - edge.p1.x;
                    const edgeDy = edge.p2.y - edge.p1.y;
                    const normalX = -edgeDy;
                    const normalY = edgeDx;
                    
                    // Check if edge faces away from player (dot product)
                    const dotProduct = dx * normalX + dy * normalY;
                    
                    if (dotProduct > 0) {
                        // This edge faces away - cast shadow
                        const shadowLength = 9600;
                        
                        // Project edge points away from player
                        const dir1X = edge.p1.x - playerCenterX;
                        const dir1Y = edge.p1.y - playerCenterY;
                        const len1 = Math.max(1, Math.sqrt(dir1X * dir1X + dir1Y * dir1Y));
                        const proj1X = edge.p1.x + (dir1X / len1) * shadowLength;
                        const proj1Y = edge.p1.y + (dir1Y / len1) * shadowLength;
                        
                        const dir2X = edge.p2.x - playerCenterX;
                        const dir2Y = edge.p2.y - playerCenterY;
                        const len2 = Math.max(1, Math.sqrt(dir2X * dir2X + dir2Y * dir2Y));
                        const proj2X = edge.p2.x + (dir2X / len2) * shadowLength;
                        const proj2Y = edge.p2.y + (dir2Y / len2) * shadowLength;
                        
                        // Draw shadow quad
                        ctx.beginPath();
                        ctx.moveTo(edge.p1.x - camera.x, edge.p1.y - camera.y);
                        ctx.lineTo(edge.p2.x - camera.x, edge.p2.y - camera.y);
                        ctx.lineTo(proj2X - camera.x, proj2Y - camera.y);
                        ctx.lineTo(proj1X - camera.x, proj1Y - camera.y);
                        ctx.closePath();
                        ctx.fill();
                    }
                }
            }
        }

        function drawDarknessOverlay() {
            ctx.save();
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.restore();
        }

        function getCoverPoint(enemy, targetX, targetY) {
            const enemyCenterX = enemy.x + enemy.width / 2;
            const enemyCenterY = enemy.y + enemy.height / 2;
            let bestObstacle = null;
            let bestScore = Infinity;

            for (let obstacle of obstacles) {
                const ox = obstacle.x + obstacle.width / 2;
                const oy = obstacle.y + obstacle.height / 2;
                const toEnemy = Math.hypot(enemyCenterX - ox, enemyCenterY - oy);
                if (toEnemy > 700) continue;

                const lineDist = distancePointToSegment(ox, oy, targetX, targetY, enemyCenterX, enemyCenterY);
                const score = lineDist + toEnemy * 0.3;

                if (score < bestScore) {
                    bestScore = score;
                    bestObstacle = obstacle;
                }
            }

            if (!bestObstacle) return null;

            const centerX = bestObstacle.x + bestObstacle.width / 2;
            const centerY = bestObstacle.y + bestObstacle.height / 2;
            const dirX = centerX - targetX;
            const dirY = centerY - targetY;
            const length = Math.hypot(dirX, dirY) || 1;
            const maxDim = Math.max(bestObstacle.width, bestObstacle.height);
            const offset = maxDim / 2 + enemy.width / 2 + 6;
            const coverX = clamp(centerX + (dirX / length) * offset, 0, mapWidth - enemy.width);
            const coverY = clamp(centerY + (dirY / length) * offset, 0, mapHeight - enemy.height);
            return { x: coverX, y: coverY };
        }

        function dropCoinsAt(x, y) {
            const coinCount = 3 + Math.floor(Math.random() * 5);
            for (let k = 0; k < coinCount; k++) {
                const angle = (k / coinCount) * Math.PI * 2 + Math.random() * 0.5;
                const distance = 20 + Math.random() * 20;
                coins.push({
                    x: x + Math.cos(angle) * distance,
                    y: y + Math.sin(angle) * distance,
                    size: 6,
                    color: '#ffcc00',
                    value: 1
                });
            }
        }

        function killEnemy(index, creditedToPlayer = false) {
            const enemy = enemies[index];
            dropCoinsAt(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
            if (creditedToPlayer) {
                enemiesKilled++;
                runEnemiesKilled++;
            }
            enemies.splice(index, 1);
        }

        function isEliteEnemy(enemy) {
            return !!enemy && enemy.isElite === true;
        }

        function getEnemyDamageAmount(enemy, rawDamage) {
            if (!enemy) return rawDamage;
            const damage = Math.max(0, rawDamage || 0);
            return isEliteEnemy(enemy) ? damage * 0.5 : damage;
        }

        function applyDamageToEnemy(enemy, rawDamage) {
            const amount = getEnemyDamageAmount(enemy, rawDamage);
            enemy.health -= amount;
            return amount;
        }

        function triggerPlayerDeath() {
            for (let i = 0; i < 30; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 4;
                particles.push({
                    x: player.x + player.width / 2,
                    y: player.y + player.height / 2,
                    velocityX: Math.cos(angle) * speed,
                    velocityY: Math.sin(angle) * speed,
                    life: 60,
                    maxLife: 60,
                    size: 4 + Math.random() * 4,
                    color: Math.random() > 0.5 ? '#ff0000' : '#ff6600'
                });
            }
            
            // Apply money penalty - divide by 10
            deathMoneyPenalty = Math.floor(money / 10);
            money = Math.max(0, money - deathMoneyPenalty);
            
            gameState = 'death';
            deathTimer = 0;
            deathMoneyCount = 0;
            deathKillsCount = 0;
        }

        function applyBurnToPlayer(damagePerTick, durationFrames) {
            player.burnTimer = Math.max(player.burnTimer, durationFrames || 0);
            player.burnTickDamage = Math.max(player.burnTickDamage, damagePerTick || 0);
            if (player.burnTickTimer <= 0) {
                player.burnTickTimer = 18;
            }
            player.burnVisualTimer = Math.max(player.burnVisualTimer, durationFrames || 0);
        }

        function applyPlayerDamage(amount) {
            if (player.invulnerable) return;
            player.health -= amount;
            player.invulnerable = true;
            player.invulnerableTime = 30;
            player.hitTimer = 10;
            addScreenShake(10, 18);
            createHitEffect(player.x + player.width / 2, player.y + player.height / 2, '#ffffff');
            playHitSound(0);

            if (player.health <= 0) {
                triggerPlayerDeath();
            }
        }

        function getEnemyTarget(enemy) {
            const enemyCenterX = enemy.x + enemy.width / 2;
            const enemyCenterY = enemy.y + enemy.height / 2;

            let bestTarget = null;
            let bestDistance = Infinity;

            for (let other of enemies) {
                if (other === enemy || other.faction === enemy.faction || isEliteEnemy(other)) continue;
                const otherCenterX = other.x + other.width / 2;
                const otherCenterY = other.y + other.height / 2;
                const dist = Math.hypot(otherCenterX - enemyCenterX, otherCenterY - enemyCenterY);
                if (dist > enemyTargetRange) {
                    continue;
                }
                if (dist < bestDistance) {
                    bestDistance = dist;
                    bestTarget = { type: 'enemy', enemy: other, x: otherCenterX, y: otherCenterY, distance: dist };
                }
            }

            return bestTarget;
        }
        function getRandomWalkablePosition(entityWidth, entityHeight) {
            for (let i = 0; i < 100; i++) {
                const zone = walkableZones[Math.floor(Math.random() * walkableZones.length)];
                const maxX = zone.x + zone.width - entityWidth;
                const maxY = zone.y + zone.height - entityHeight;
                if (maxX <= zone.x || maxY <= zone.y) {
                    continue;
                }

                const x = zone.x + Math.random() * (maxX - zone.x);
                const y = zone.y + Math.random() * (maxY - zone.y);

                if (!checkObstacleCollision(x, y, entityWidth, entityHeight)) {
                    return { x, y };
                }
            }

            return {
                x: clamp(player.x + (Math.random() - 0.5) * 240, 0, mapWidth - entityWidth),
                y: clamp(player.y + (Math.random() - 0.5) * 240, 0, mapHeight - entityHeight)
            };
        }

        function getSpawnPointOffscreen(entityWidth, entityHeight) {
            const padding = 80;
            const viewX = camera.x - padding;
            const viewY = camera.y - padding;
            const viewW = canvas.width + padding * 2;
            const viewH = canvas.height + padding * 2;

            for (let i = 0; i < 80; i++) {
                const candidate = getRandomWalkablePosition(entityWidth, entityHeight);
                const x = candidate.x;
                const y = candidate.y;

                const inView = rectsIntersect(x, y, entityWidth, entityHeight, viewX, viewY, viewW, viewH);
                if (inView) continue;
                if (checkObstacleCollision(x, y, entityWidth, entityHeight)) continue;

                return { x, y };
            }

            // Fallback: any valid walkable spot
            return getRandomWalkablePosition(entityWidth, entityHeight);
        }

        // Spawn enemies based on difficulty
        function spawnEnemies() {
            spawnTimer--;
            
            // Spawn rate increases with difficulty
            const spawnRate = Math.max(60, 180 - (difficulty * 8)); // Slower initial spawn, increases with level
            
            if (spawnTimer <= 0) {
                spawnTimer = spawnRate;

                let baseGroupSize = 2 + Math.floor(difficulty / 4);
                if (difficulty >= 2) {
                    baseGroupSize += 1;
                }
                const groupSize = Math.min(baseGroupSize, 8);
                const factionCount = enemyFactions.length;

                for (let f = 0; f < factionCount; f++) {
                    const faction = enemyFactions[f];
                    const groupSpawn = getSpawnPointOffscreen(40, 40);

                    for (let i = 0; i < groupSize; i++) {
                        const spread = 80;
                        const x = clamp(groupSpawn.x + (Math.random() - 0.5) * spread, 0, mapWidth - 40);
                        const y = clamp(groupSpawn.y + (Math.random() - 0.5) * spread, 0, mapHeight - 40);
                        if (checkObstacleCollision(x, y, 40, 40) || !isRectInWalkableArea(x, y, 40, 40)) {
                            continue;
                        }

                        const variant = chooseEnemyVariant();
                        const weaponId = variant === 'melee' ? null : (variant === 'special' ? chooseSpecialWeaponId() : chooseEnemyWeaponId());
                        const weaponConfig = weaponId ? (enemyWeaponConfigs[weaponId] || enemyWeaponConfigs.handgun) : null;
                        const ammoProfile = getEnemyAmmoProfile(weaponId);

                        enemies.push({
                            x: x,
                            y: y,
                            width: 40,
                            height: 40,
                            speed: variant === 'melee' ? 1.7 + (difficulty * 0.06) : 0.8 + (difficulty * 0.05),
                            health: variant === 'special' ? 12 : (variant === 'melee' ? 5 : 3),
                            faction: faction.id,
                            color: variant === 'special' ? '#ffcc66' : (variant === 'melee' ? '#ff884d' : faction.color),
                            weaponId: weaponId,
                            variant: variant,
                            meleeDamage: variant === 'melee' ? 16 : 10,
                            behavior: variant === 'melee' ? 'melee' : 'shoot',
                            behaviorTimer: 90 + Math.floor(Math.random() * 60),
                            coverPoint: null,
                            coverAction: 'cover',
                            peekPoint: null,
                            coverRecalcTimer: 0,
                            shootCooldown: weaponConfig ? Math.floor(Math.random() * weaponConfig.fireCooldownFrames) : 0,
                            reloadTimer: 0,
                            reloadDuration: ammoProfile.reloadFrames,
                            ammo: ammoProfile.maxAmmo,
                            maxAmmo: ammoProfile.maxAmmo,
                            alertTimer: 0,
                            alertTargetX: 0,
                            alertTargetY: 0,
                            facingAngle: Math.random() * Math.PI * 2,
                            desiredFacingAngle: 0,
                            lookOffset: Math.random() * Math.PI * 2,
                            lastSeenTimer: 0,
                            lastSeenX: 0,
                            lastSeenY: 0,
                            wanderOffsetX: (Math.random() - 0.5) * 140,
                            wanderOffsetY: (Math.random() - 0.5) * 140,
                            hitTimer: 0,
                            wallFollowDirX: 0,
                            wallFollowDirY: 0,
                            wallFollowTimer: 0,
                            isElite: false,
                            eliteType: null,
                            sniperWarningTimer: 0,
                            sniperTargetX: 0,
                            sniperTargetY: 0
                        });
                    }
                }

                if (difficulty >= 4 && Math.random() < 0.65) {
                    const eliteSpawn = getSpawnPointOffscreen(46, 46);
                    const eliteCount = Math.min(1 + Math.floor((difficulty - 4) / 6), 3);

                    for (let e = 0; e < eliteCount; e++) {
                        const spread = 70;
                        const x = clamp(eliteSpawn.x + (Math.random() - 0.5) * spread, 0, mapWidth - 46);
                        const y = clamp(eliteSpawn.y + (Math.random() - 0.5) * spread, 0, mapHeight - 46);
                        if (checkObstacleCollision(x, y, 46, 46) || !isRectInWalkableArea(x, y, 46, 46)) {
                            continue;
                        }

                        const eliteType = chooseEliteVariant();
                        const weaponId = getEliteWeaponId(eliteType);
                        const weaponConfig = enemyWeaponConfigs[weaponId] || enemyWeaponConfigs.handgun;
                        const ammoProfile = getEnemyAmmoProfile(weaponId);
                        const isSniper = eliteType === 'eliteSniper';
                        const isMinigun = eliteType === 'eliteMinigun';

                        enemies.push({
                            x,
                            y,
                            width: 46,
                            height: 46,
                            speed: isSniper ? 1.8 + (difficulty * 0.05) : (isMinigun ? 1.1 + (difficulty * 0.04) : 1.35 + (difficulty * 0.06)),
                            health: isSniper ? 14 : (isMinigun ? 28 : 16),
                            faction: eliteFactionId,
                            color: eliteColor,
                            weaponId,
                            variant: eliteType,
                            meleeDamage: 14,
                            behavior: 'shoot',
                            behaviorTimer: 999,
                            coverPoint: null,
                            coverAction: 'hold',
                            peekPoint: null,
                            coverRecalcTimer: 0,
                            shootCooldown: Math.floor(Math.random() * Math.max(1, weaponConfig.fireCooldownFrames)),
                            reloadTimer: 0,
                            reloadDuration: 0,
                            ammo: 0,
                            maxAmmo: 0,
                            alertTimer: 300,
                            alertTargetX: 0,
                            alertTargetY: 0,
                            facingAngle: Math.random() * Math.PI * 2,
                            desiredFacingAngle: 0,
                            lookOffset: Math.random() * Math.PI * 2,
                            lastSeenTimer: 0,
                            lastSeenX: 0,
                            lastSeenY: 0,
                            wanderOffsetX: (Math.random() - 0.5) * 140,
                            wanderOffsetY: (Math.random() - 0.5) * 140,
                            hitTimer: 0,
                            wallFollowDirX: 0,
                            wallFollowDirY: 0,
                            wallFollowTimer: 0,
                            isElite: true,
                            eliteType,
                            sniperWarningTimer: 0,
                            sniperTargetX: 0,
                            sniperTargetY: 0
                        });
                    }
                }
            }
        }

        // Update enemies
        function updateEnemies() {
            for (let f = 0; f < factionWander.length; f++) {
                const wander = factionWander[f];
                if (wander.timer > 0) {
                    wander.timer--;
                }
                if (wander.timer <= 0) {
                    const spot = getRandomWalkablePosition(40, 40);
                    wander.x = spot.x;
                    wander.y = spot.y;
                    wander.timer = 360 + Math.floor(Math.random() * 420);
                }
            }

            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                const centerX = enemy.x + enemy.width / 2;
                const centerY = enemy.y + enemy.height / 2;
                if (!Number.isFinite(enemy.facingAngle)) {
                    enemy.facingAngle = 0;
                }
                if (!Number.isFinite(enemy.desiredFacingAngle)) {
                    enemy.desiredFacingAngle = enemy.facingAngle;
                }
                if (!Number.isFinite(enemy.alertTargetX)) {
                    enemy.alertTargetX = centerX;
                }
                if (!Number.isFinite(enemy.alertTargetY)) {
                    enemy.alertTargetY = centerY;
                }
                const playerCenterX = player.x + player.width / 2;
                const playerCenterY = player.y + player.height / 2;
                const canSeePlayer = canEnemySeeTarget(enemy, playerCenterX, playerCenterY);
                const isMelee = enemy.variant === 'melee';
                const enemyTarget = isMelee ? null : getEnemyTarget(enemy);
                const hasEnemyTarget = !!enemyTarget;

                if (canSeePlayer) {
                    enemy.lastSeenTimer = 200;
                    enemy.lastSeenX = playerCenterX;
                    enemy.lastSeenY = playerCenterY;
                }

                if (!canSeePlayer && !hasEnemyTarget && noise.value > 0) {
                    const noiseRadius = noise.baseRadius + noise.value * noise.maxRadius;
                    const distToNoise = Math.hypot(noise.x - centerX, noise.y - centerY);
                    if (distToNoise <= noiseRadius) {
                        enemy.alertTimer = 240;
                        enemy.alertTargetX = noise.x;
                        enemy.alertTargetY = noise.y;
                    }
                }

                if (enemy.alertTimer > 0) {
                    enemy.alertTimer--;
                }
                if (enemy.lastSeenTimer > 0) {
                    enemy.lastSeenTimer--;
                }
                if (!isElite && enemy.reloadTimer > 0) {
                    enemy.reloadTimer--;
                    if (enemy.reloadTimer <= 0) {
                        enemy.ammo = enemy.maxAmmo || 0;
                    }
                }

                let target;
                if (canSeePlayer) {
                    target = { type: 'player', x: playerCenterX, y: playerCenterY, distance: Math.hypot(playerCenterX - centerX, playerCenterY - centerY) };
                } else if (enemy.lastSeenTimer > 0) {
                    target = { type: 'memory', x: enemy.lastSeenX, y: enemy.lastSeenY, distance: Math.hypot(enemy.lastSeenX - centerX, enemy.lastSeenY - centerY) };
                } else if (hasEnemyTarget) {
                    target = enemyTarget;
                } else if (enemy.alertTimer <= 0 && enemy.faction < factionWander.length) {
                    const wander = factionWander[enemy.faction];
                    target = {
                        type: 'wander',
                        x: wander.x + (enemy.wanderOffsetX || 0),
                        y: wander.y + (enemy.wanderOffsetY || 0),
                        distance: Math.hypot(wander.x + (enemy.wanderOffsetX || 0) - centerX, wander.y + (enemy.wanderOffsetY || 0) - centerY)
                    };
                } else {
                    target = null;
                }

                if (target) {
                    enemy.desiredFacingAngle = Math.atan2(target.y - centerY, target.x - centerX);
                } else if (enemy.alertTimer > 0 && !hasEnemyTarget) {
                    const baseAngle = Math.atan2(enemy.alertTargetY - centerY, enemy.alertTargetX - centerX);
                    const sweep = Math.sin(performance.now() * 0.004 + (enemy.lookOffset || 0)) * (enemyFovAngle * 0.6);
                    enemy.desiredFacingAngle = baseAngle + sweep;
                }

                enemy.facingAngle = lerpAngle(enemy.facingAngle || 0, enemy.desiredFacingAngle || 0, 0.08);

                const targetX = target ? target.x : centerX;
                const targetY = target ? target.y : centerY;
                const dx = targetX - centerX;
                const dy = targetY - centerY;
                const distance = Math.hypot(dx, dy) || 1;
                const hasLOS = target ? hasLineOfSight(centerX, centerY, targetX, targetY) : false;
                const isElite = isEliteEnemy(enemy);
                const isEliteSniper = enemy.eliteType === 'eliteSniper';

                if (!isMelee && target) {
                    if (target.type === 'player') {
                        enemy.behavior = 'shoot';
                        enemy.coverPoint = null;
                        enemy.peekPoint = null;
                        enemy.behaviorTimer = Math.max(enemy.behaviorTimer, 60);
                    }
                    if (isElite) {
                        enemy.behavior = 'shoot';
                        enemy.coverPoint = null;
                        enemy.peekPoint = null;
                    } else {
                        enemy.behaviorTimer--;
                        if (enemy.behaviorTimer <= 0) {
                            if (enemy.behavior === 'shoot') {
                                enemy.behavior = 'cover';
                                enemy.behaviorTimer = 80 + Math.floor(Math.random() * 60);
                                enemy.coverPoint = getCoverPoint(enemy, targetX, targetY);
                                enemy.coverRecalcTimer = 40;
                                enemy.peekPoint = null;
                                const roll = Math.random();
                                enemy.coverAction = roll < 0.5 ? 'cover' : roll < 0.8 ? 'peek' : 'hold';
                                if (!enemy.coverPoint) {
                                    enemy.behavior = 'shoot';
                                    enemy.behaviorTimer = 100 + Math.floor(Math.random() * 80);
                                }
                            } else {
                                enemy.behavior = 'shoot';
                                enemy.behaviorTimer = 100 + Math.floor(Math.random() * 80);
                                enemy.coverPoint = null;
                                enemy.peekPoint = null;
                            }
                        }
                    }
                }

                let moveX = 0;
                let moveY = 0;

                if (isMelee) {
                    if (target && (target.type === 'player' || target.type === 'memory')) {
                        moveTowardWithAvoidance(enemy, targetX, targetY, enemy.speed);
                    } else if (target && target.type === 'wander') {
                        moveX = (dx / distance) * enemy.speed * 0.7;
                        moveY = (dy / distance) * enemy.speed * 0.7;
                    }
                } else if (target && enemy.behavior === 'cover' && target.type !== 'wander') {
                    enemy.coverRecalcTimer--;
                    if (!enemy.coverPoint || enemy.coverRecalcTimer <= 0) {
                        enemy.coverPoint = getCoverPoint(enemy, targetX, targetY);
                        enemy.coverRecalcTimer = 40;
                        enemy.peekPoint = null;
                    }

                    if (enemy.coverPoint) {
                        if (enemy.coverAction === 'cover') {
                            const cdx = enemy.coverPoint.x - enemy.x;
                            const cdy = enemy.coverPoint.y - enemy.y;
                            const cdist = Math.hypot(cdx, cdy);
                            if (cdist > 4) {
                                moveX = (cdx / cdist) * enemy.speed;
                                moveY = (cdy / cdist) * enemy.speed;
                            }
                        } else if (enemy.coverAction === 'peek') {
                            if (!enemy.peekPoint) {
                                const toTargetX = targetX - enemy.coverPoint.x;
                                const toTargetY = targetY - enemy.coverPoint.y;
                                const len = Math.hypot(toTargetX, toTargetY) || 1;
                                const peekOffset = 80;
                                enemy.peekPoint = {
                                    x: clamp(enemy.coverPoint.x + (toTargetX / len) * peekOffset, 0, mapWidth - enemy.width),
                                    y: clamp(enemy.coverPoint.y + (toTargetY / len) * peekOffset, 0, mapHeight - enemy.height)
                                };
                            }
                            const pdx = enemy.peekPoint.x - enemy.x;
                            const pdy = enemy.peekPoint.y - enemy.y;
                            const pdist = Math.hypot(pdx, pdy);
                            if (pdist > 4) {
                                moveX = (pdx / pdist) * enemy.speed;
                                moveY = (pdy / pdist) * enemy.speed;
                            }
                        }
                    }
                } else if (target) {
                    const desiredRange = isEliteSniper ? 560 : (enemy.eliteType === 'eliteFlame' ? 190 : (enemy.eliteType === 'eliteMinigun' ? 280 : 240));
                    if (target.type === 'wander') {
                        moveX = (dx / distance) * enemy.speed * 0.65;
                        moveY = (dy / distance) * enemy.speed * 0.65;
                    } else if (!hasLOS) {
                        moveAlongWall(enemy, targetX, targetY, enemy.speed);
                    } else {
                        enemy.wallFollowTimer = 0;
                        enemy.wallFollowDirX = 0;
                        enemy.wallFollowDirY = 0;
                        if (distance > desiredRange * 1.1) {
                            moveX = (dx / distance) * enemy.speed;
                            moveY = (dy / distance) * enemy.speed;
                        } else if (distance < desiredRange * 0.7) {
                            moveX = (-dx / distance) * enemy.speed;
                            moveY = (-dy / distance) * enemy.speed;
                        } else if (isElite) {
                            const strafeAngle = Math.atan2(dy, dx) + (Math.random() > 0.5 ? Math.PI / 2 : -Math.PI / 2);
                            moveX = Math.cos(strafeAngle) * enemy.speed * 0.75;
                            moveY = Math.sin(strafeAngle) * enemy.speed * 0.75;
                        }
                    }
                }

                if (moveX !== 0 || moveY !== 0) {
                    moveEntityWithCollisions(enemy, moveX, moveY);
                    enemy.desiredFacingAngle = Math.atan2(moveY, moveX);
                }

                // Re-evaluate LOS after movement for cover decisions
                const movedCenterX = enemy.x + enemy.width / 2;
                const movedCenterY = enemy.y + enemy.height / 2;
                const movedHasLOS = target ? hasLineOfSight(movedCenterX, movedCenterY, targetX, targetY) : false;

                if (!isMelee && target && enemy.behavior === 'cover' && enemy.coverAction !== 'hold') {
                    if (enemy.coverAction === 'cover' && movedHasLOS) {
                        enemy.coverAction = 'peek';
                        enemy.peekPoint = null;
                    } else if (enemy.coverAction === 'peek' && !movedHasLOS) {
                        enemy.coverAction = 'cover';
                    }
                }

                if (!isMelee && target && enemy.behavior === 'shoot') {
                    if (!isElite && enemy.maxAmmo > 0 && enemy.reloadTimer > 0) {
                        continue;
                    }

                    if (!isElite && enemy.maxAmmo > 0 && enemy.ammo <= 0) {
                        enemy.reloadTimer = enemy.reloadDuration || 120;
                        continue;
                    }

                    const weapon = getEnemyWeaponConfig(enemy);
                    const maxShootRange = target.type === 'player'
                        ? enemySightRange
                        : (isEliteSniper ? 1300 : 700);
                    if (isEliteSniper && enemy.sniperWarningTimer > 0) {
                        enemy.sniperWarningTimer--;
                        if (enemy.sniperWarningTimer <= 0) {
                            const shootDx = enemy.sniperTargetX - movedCenterX;
                            const shootDy = enemy.sniperTargetY - movedCenterY;
                            const baseAngle = Math.atan2(shootDy, shootDx);
                            enemyBullets.push({
                                x: movedCenterX,
                                y: movedCenterY,
                                velocityX: Math.cos(baseAngle) * weapon.bulletSpeed,
                                velocityY: Math.sin(baseAngle) * weapon.bulletSpeed,
                                size: weapon.bulletSize,
                                color: '#ff3333',
                                faction: enemy.faction,
                                damage: weapon.damage,
                                sourceElite: isElite,
                                appliesBurn: false,
                                burnDamage: 0,
                                burnDuration: 0,
                                trail: [],
                                trailMax: Math.max(bulletTrailMin, Math.min(bulletTrailMax, Math.round(weapon.bulletSpeed)))
                            });
                            const playerDistance = Math.hypot(movedCenterX - playerCenterX, movedCenterY - playerCenterY);
                            playGunshot(playerDistance);
                            enemy.shootCooldown = weapon.fireCooldownFrames + Math.floor(Math.random() * 4);
                            if (!isElite && enemy.maxAmmo > 0) {
                                enemy.ammo -= 1;
                                if (enemy.ammo <= 0) {
                                    enemy.reloadTimer = enemy.reloadDuration || 120;
                                }
                            }
                        }
                    } else if (enemy.shootCooldown > 0) {
                        enemy.shootCooldown--;
                    } else if (distance < maxShootRange && movedHasLOS) {
                        if (isEliteSniper) {
                            enemy.sniperWarningTimer = 24;
                            enemy.sniperTargetX = playerCenterX;
                            enemy.sniperTargetY = playerCenterY;
                        } else {
                            const shootDx = targetX - movedCenterX;
                            const shootDy = targetY - movedCenterY;
                            const baseAngle = Math.atan2(shootDy, shootDx);
                            for (let shot = 0; shot < weapon.shotsPerTrigger; shot++) {
                                const spreadOffset = (Math.random() - 0.5) * weapon.spread;
                                const angle = baseAngle + spreadOffset;
                                enemyBullets.push({
                                    x: movedCenterX,
                                    y: movedCenterY,
                                    velocityX: Math.cos(angle) * weapon.bulletSpeed,
                                    velocityY: Math.sin(angle) * weapon.bulletSpeed,
                                    size: weapon.bulletSize,
                                    color: enemy.color,
                                    faction: enemy.faction,
                                    damage: weapon.damage,
                                    sourceElite: isElite,
                                    appliesBurn: !!weapon.appliesBurn,
                                    burnDamage: weapon.burnDamage || 0,
                                    burnDuration: weapon.burnDuration || 0,
                                    trail: [],
                                    trailMax: Math.max(bulletTrailMin, Math.min(bulletTrailMax, Math.round(weapon.bulletSpeed)))
                                });
                            }
                            const playerDistance = Math.hypot(movedCenterX - playerCenterX, movedCenterY - playerCenterY);
                            playGunshot(playerDistance);
                            enemy.shootCooldown = weapon.fireCooldownFrames + Math.floor(Math.random() * 6);
                            if (!isElite && enemy.maxAmmo > 0) {
                                enemy.ammo -= 1;
                                if (enemy.ammo <= 0) {
                                    enemy.reloadTimer = enemy.reloadDuration || 120;
                                }
                            }
                        }
                    }
                } else if (!isMelee && enemy.shootCooldown > 0) {
                    enemy.shootCooldown--;
                }

                // Melee collision with player
                if (rectsIntersect(enemy.x, enemy.y, enemy.width, enemy.height, player.x, player.y, player.width, player.height)) {
                    applyPlayerDamage(enemy.meleeDamage || 10);
                }

                // Check collision with player bullets
                let killed = false;
                for (let j = bullets.length - 1; j >= 0; j--) {
                    if (bullets[j].x > enemy.x && 
                        bullets[j].x < enemy.x + enemy.width &&
                        bullets[j].y > enemy.y && 
                        bullets[j].y < enemy.y + enemy.height) {
                        
                        applyDamageToEnemy(enemy, bullets[j].damage || 1);
                        enemy.hitTimer = 10;
                        const hitCenterX = enemy.x + enemy.width / 2;
                        const hitCenterY = enemy.y + enemy.height / 2;
                        enemy.lastSeenTimer = 240;
                        enemy.lastSeenX = playerCenterX;
                        enemy.lastSeenY = playerCenterY;
                        enemy.desiredFacingAngle = Math.atan2(playerCenterY - hitCenterY, playerCenterX - hitCenterX);
                        createHitEffect(bullets[j].x, bullets[j].y, '#ff6666');
                        const playerDistance = Math.hypot(bullets[j].x - playerCenterX, bullets[j].y - playerCenterY);
                        playHitSound(playerDistance);
                        createExplosion(bullets[j].x, bullets[j].y);
                        bullets.splice(j, 1);

                        if (enemy.health <= 0) {
                            killEnemy(i, true);
                            killed = true;
                        }
                        break;
                    }
                }

                if (killed) {
                    continue;
                }

                if (enemy.hitTimer > 0) {
                    enemy.hitTimer--;
                }
            }
            
            // Update invulnerability
            if (player.invulnerable) {
                player.invulnerableTime--;
                if (player.invulnerableTime <= 0) {
                    player.invulnerable = false;
                }
            }
        }

        // Update difficulty
        function updateDifficulty() {
            if (difficulty < maxDifficulty) {
                difficultyProgress += difficultyIncreaseRate;
                
                // When progress reaches 100, level up and reset progress
                if (difficultyProgress >= 100) {
                    difficulty++;
                    difficultyProgress = 0;
                    
                    if (difficulty > maxDifficulty) {
                        difficulty = maxDifficulty;
                    }
                }
            }
        }

        // Update coins
        function updateCoins() {
            const pickupRadius = 40;
            
            for (let i = coins.length - 1; i >= 0; i--) {
                const coin = coins[i];
                const dx = (player.x + player.width / 2) - coin.x;
                const dy = (player.y + player.height / 2) - coin.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Magnetic pull only if within pickup radius
                if (distance < pickupRadius && distance > 0) {
                    const pullSpeed = 5;
                    coin.x += (dx / distance) * pullSpeed;
                    coin.y += (dy / distance) * pullSpeed;
                    
                    // Pick up coin if very close to player center
                    if (distance < 10) {
                        money += coin.value;
                        runMoneyEarned += coin.value;
                        coins.splice(i, 1);
                    }
                }
            }
        }

        // Draw player
        function drawPlayer() {
            ctx.fillStyle = player.color;
            ctx.fillRect(
                player.x - camera.x,
                player.y - camera.y,
                player.width,
                player.height
            );

            if (player.burnVisualTimer > 0) {
                const pulse = 0.35 + 0.25 * Math.sin(performance.now() * 0.03);
                ctx.globalAlpha = Math.max(0.2, pulse);
                ctx.fillStyle = '#ff6633';
                ctx.fillRect(
                    player.x - camera.x - 2,
                    player.y - camera.y - 2,
                    player.width + 4,
                    player.height + 4
                );
                ctx.globalAlpha = 1;
            }

            if (player.dashTimer > 0) {
                ctx.globalAlpha = player.dashTimer / player.dashFrames;
                ctx.fillStyle = '#66ff66';
                ctx.fillRect(
                    player.x - camera.x - player.dashVelocityX * 1.5,
                    player.y - camera.y - player.dashVelocityY * 1.5,
                    player.width,
                    player.height
                );
                ctx.globalAlpha = 1;
            }

            if (player.meleeEffectTimer > 0) {
                const centerX = player.x + player.width / 2 - camera.x;
                const centerY = player.y + player.height / 2 - camera.y;
                const angle = Math.atan2(player.meleeDirY, player.meleeDirX);
                const arcSize = Math.PI * 0.85;
                ctx.strokeStyle = '#ffeeaa';
                ctx.lineWidth = 4;
                ctx.globalAlpha = player.meleeEffectTimer / 8;
                ctx.beginPath();
                ctx.arc(centerX, centerY, player.meleeRange * 0.65, angle - arcSize / 2, angle + arcSize / 2);
                ctx.stroke();
                ctx.globalAlpha = 1;
            }

            if (player.hitTimer > 0) {
                ctx.globalAlpha = player.hitTimer / 10;
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(
                    player.x - camera.x,
                    player.y - camera.y,
                    player.width,
                    player.height
                );
                ctx.globalAlpha = 1;
            }

            // Draw reload bar above player if reloading
            if (player.isReloading) {
                const barWidth = 40;
                const barHeight = 5;
                const barX = player.x - camera.x + player.width / 2 - barWidth / 2;
                const barY = player.y - camera.y - 15;

                // Background bar
                ctx.fillStyle = '#333';
                ctx.fillRect(barX, barY, barWidth, barHeight);

                // Filled bar (green to red gradient)
                const reloadProgress = 1 - (player.reloadTime / player.maxReloadTime);
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(barX, barY, barWidth * reloadProgress, barHeight);

                // Border
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.strokeRect(barX, barY, barWidth, barHeight);
            }
        }

        // Draw bullets
        function drawBullets() {
            for (let bullet of bullets) {
                drawBulletTrail(bullet);
                ctx.fillStyle = bullet.color;
                ctx.beginPath();
                ctx.arc(
                    bullet.x - camera.x,
                    bullet.y - camera.y,
                    bullet.size,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
            }
        }

        // Draw enemy bullets
        function drawEnemyBullets() {
            for (let bullet of enemyBullets) {
                drawBulletTrail(bullet);
                ctx.fillStyle = bullet.color;
                ctx.beginPath();
                ctx.arc(
                    bullet.x - camera.x,
                    bullet.y - camera.y,
                    bullet.size,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
            }
        }

        // Draw particles
        function drawParticles() {
            for (let particle of particles) {
                ctx.fillStyle = particle.color;
                ctx.globalAlpha = particle.life / particle.maxLife;
                ctx.beginPath();
                ctx.arc(
                    particle.x - camera.x,
                    particle.y - camera.y,
                    particle.size,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        // Draw enemies
        function drawEnemies() {
            const playerCenterX = player.x + player.width / 2;
            const playerCenterY = player.y + player.height / 2;
            for (let enemy of enemies) {
                const enemyCenterX = enemy.x + enemy.width / 2;
                const enemyCenterY = enemy.y + enemy.height / 2;
                // Only check line of sight, no radius limit
                if (!hasLineOfSight(playerCenterX, playerCenterY, enemyCenterX, enemyCenterY)) {
                    continue;
                }
                const safeFacing = Number.isFinite(enemy.facingAngle) ? enemy.facingAngle : 0;
                const coneAngle = enemyFovAngle;
                const coneLength = enemyConeLength;
                const startAngle = safeFacing - coneAngle / 2;
                const endAngle = safeFacing + coneAngle / 2;

                ctx.save();
                ctx.globalAlpha = 0.16;
                ctx.fillStyle = '#fff6cc';
                ctx.beginPath();
                ctx.moveTo(enemyCenterX - camera.x, enemyCenterY - camera.y);
                ctx.arc(enemyCenterX - camera.x, enemyCenterY - camera.y, coneLength, startAngle, endAngle);
                ctx.closePath();
                ctx.fill();
                ctx.restore();

                ctx.fillStyle = enemy.color;
                ctx.fillRect(
                    enemy.x - camera.x,
                    enemy.y - camera.y,
                    enemy.width,
                    enemy.height
                );

                const label = enemy.isElite
                    ? (enemy.eliteType === 'eliteSniper' ? 'ELITE SNIPER' : (enemy.eliteType === 'eliteMinigun' ? 'ELITE MINIGUN' : 'ELITE FLAME'))
                    : (enemy.variant === 'special' ? 'SPECIAL' : (enemy.variant === 'melee' ? 'MELEE' : (enemy.weaponId ? enemy.weaponId.toUpperCase() : 'RANGED')));
                ctx.fillStyle = '#ffffff';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText(label, enemyCenterX - camera.x, enemy.y - camera.y - 4);

                if (!enemy.isElite && enemy.reloadTimer > 0) {
                    ctx.fillStyle = '#ffeeaa';
                    ctx.font = '11px Arial';
                    ctx.textBaseline = 'bottom';
                    ctx.fillText('RELOADING', enemyCenterX - camera.x, enemy.y - camera.y - 18);
                }

                if (enemy.eliteType === 'eliteSniper' && enemy.sniperWarningTimer > 0) {
                    ctx.save();
                    ctx.globalAlpha = Math.min(0.85, 0.35 + enemy.sniperWarningTimer / 30);
                    ctx.strokeStyle = '#ff2222';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(enemyCenterX - camera.x, enemyCenterY - camera.y);
                    ctx.lineTo(enemy.sniperTargetX - camera.x, enemy.sniperTargetY - camera.y);
                    ctx.stroke();

                    ctx.fillStyle = '#ff4444';
                    ctx.beginPath();
                    ctx.arc(enemy.sniperTargetX - camera.x, enemy.sniperTargetY - camera.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }

                if (enemy.hitTimer > 0) {
                    ctx.globalAlpha = enemy.hitTimer / 10;
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(
                        enemy.x - camera.x,
                        enemy.y - camera.y,
                        enemy.width,
                        enemy.height
                    );
                    ctx.globalAlpha = 1;
                }
            }
            ctx.globalAlpha = 1; // Ensure alpha is reset after drawing all enemies
        }

        // Draw coins
        function drawCoins() {
            const playerCenterX = player.x + player.width / 2;
            const playerCenterY = player.y + player.height / 2;
            for (let coin of coins) {
                // Only check line of sight, no radius limit
                if (!hasLineOfSight(playerCenterX, playerCenterY, coin.x, coin.y)) {
                    continue;
                }
                ctx.fillStyle = coin.color;
                ctx.beginPath();
                ctx.arc(
                    coin.x - camera.x,
                    coin.y - camera.y,
                    coin.size,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                
                // Outline
                ctx.strokeStyle = '#cc9900';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }

        // Draw difficulty bar at top of screen
        function drawDifficultyBar() {
            const barWidth = 300;
            const barHeight = 20;
            const barX = canvas.width / 2 - barWidth / 2;
            const barY = 20;

            // Background
            ctx.fillStyle = '#333';
            ctx.fillRect(barX, barY, barWidth, barHeight);

            // Filled portion (gradient from green to red based on level)
            const fillWidth = (difficultyProgress / 100) * barWidth;
            const colorValue = Math.floor((difficulty / maxDifficulty) * 255);
            ctx.fillStyle = `rgb(${colorValue}, ${255 - colorValue}, 0)`;
            ctx.fillRect(barX, barY, fillWidth, barHeight);

            // Border
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(barX, barY, barWidth, barHeight);

            // Text
            ctx.fillStyle = '#fff';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`Level ${difficulty} - ${Math.floor(difficultyProgress)}%`, canvas.width / 2, barY + barHeight / 2);
        }

        // Draw money counter
        function drawMoneyCounter() {
            ctx.fillStyle = '#ffcc00';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText(`$${money}`, 20, 20);
            
            // Draw coin icon
            ctx.beginPath();
            ctx.arc(15, 27, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#cc9900';
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        // Draw health bar
        function drawHealthBar() {
            const barWidth = 200;
            const barHeight = 20;
            const barX = 20;
            const barY = 50;

            // Background
            ctx.fillStyle = '#333';
            ctx.fillRect(barX, barY, barWidth, barHeight);

            // Health fill (green to red based on health)
            const healthPercent = player.health / player.maxHealth;
            ctx.fillStyle = healthPercent > 0.5 ? '#00ff00' : healthPercent > 0.25 ? '#ffaa00' : '#ff0000';
            ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);

            // Border
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(barX, barY, barWidth, barHeight);

            // Text
            ctx.fillStyle = '#fff';
            ctx.font = '14px Arial';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.fillText(`HP: ${player.health}/${player.maxHealth}`, barX + 5, barY + barHeight / 2);
        }

        function getValidPlayerSpawn() {
            // Define safe spawn areas (center of main walkable zones)
            const safeLocations = [
                { x: 3200, y: 2200 },  // Middle of top zone
                { x: 4300, y: 2500 },  // Center-ish
                { x: 2500, y: 2800 },  // Left-center
                { x: 5500, y: 2800 },  // Right-center
                { x: 3800, y: 3500 }   // Lower center
            ];

            // Test each safe location
            for (let loc of safeLocations) {
                if (!checkObstacleCollision(loc.x, loc.y, player.width, player.height)) {
                    return loc;
                }
            }

            // Fallback: find the closest valid position near center
            const centerX = mapWidth / 2;
            const centerY = mapHeight / 2;
            let bestSpawn = null;
            let bestDistance = Infinity;

            for (let attempt = 0; attempt < 50; attempt++) {
                const spawn = getRandomWalkablePosition(player.width, player.height);
                const distance = Math.hypot(spawn.x - centerX, spawn.y - centerY);
                
                if (distance < bestDistance) {
                    bestDistance = distance;
                    bestSpawn = spawn;
                }
            }

            return bestSpawn || { x: 3200, y: 2200 };
        }

        function resetRunState() {
            isPaused = false;
            loadTransientStateFromQuery();
            
            // Use hardcoded safe position instead of getRandomWalkablePosition
            player.x = 3000;
            player.y = 2300;
            
            // Reset camera to follow new spawn position
            camera.x = player.x - canvas.width / 2 + player.width / 2;
            camera.y = player.y - canvas.height / 2 + player.height / 2;
            if (camera.x < 0) camera.x = 0;
            if (camera.x + canvas.width > mapWidth) camera.x = mapWidth - canvas.width;
            if (camera.y < 0) camera.y = 0;
            if (camera.y + canvas.height > mapHeight) camera.y = mapHeight - canvas.height;
            
            player.health = player.maxHealth;
            applySelectedWeapon(true);
            player.isReloading = false;
            player.fireCooldown = 0;
            player.invulnerable = false;
            player.invulnerableTime = 0;
            player.hitTimer = 0;
            player.dashCooldown = 0;
            player.dashTimer = 0;
            player.dashVelocityX = 0;
            player.dashVelocityY = 0;
            player.meleeCooldown = 0;
            player.meleeEffectTimer = 0;
            player.burnTimer = 0;
            player.burnTickTimer = 0;
            player.burnTickDamage = 0;
            player.burnVisualTimer = 0;
            mouseButtons.left = false;
            screenShake.intensity = 0;
            screenShake.timer = 0;
            difficulty = 1;
            difficultyProgress = 0;
            enemies.length = 0;
            deathMoneyPenalty = 0;
            // spawnExtractDoor(); // DISABLED FOR TESTING
            bullets.length = 0;
            enemyBullets.length = 0;
            coins.length = 0;
            particles.length = 0;
            spawnTimer = 0;
            runEnemiesKilled = 0;
            runMoneyEarned = 0;
        }

        // Update death screen
        function updateDeathScreen() {
            deathTimer++;
            
            const explosionDuration = 200;
            
            // Count up money after explosion + 120 frames (2 seconds)
            if (deathTimer > explosionDuration + 120 && deathMoneyCount < runMoneyEarned) {
                deathMoneyCount += Math.ceil((runMoneyEarned - deathMoneyCount) * 0.1);
                if (deathMoneyCount > runMoneyEarned) deathMoneyCount = runMoneyEarned;
            }
            
            // Count up kills after explosion + 180 frames (3 seconds)
            if (deathTimer > explosionDuration + 180 && deathKillsCount < runEnemiesKilled) {
                deathKillsCount += Math.ceil((runEnemiesKilled - deathKillsCount) * 0.1);
                if (deathKillsCount > runEnemiesKilled) deathKillsCount = runEnemiesKilled;
            }
        }

        // Draw death screen
        function drawDeathScreen() {
            // Slow motion effect on particles
            const slowMoFactor = 0.3;
            
            // Update particles in slow motion
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].x += particles[i].velocityX * slowMoFactor;
                particles[i].y += particles[i].velocityY * slowMoFactor;
                particles[i].life -= 0.3;

                if (particles[i].life <= 0) {
                    particles.splice(i, 1);
                }
            }
            
            // Draw game background dimmed
            drawBackground();
            drawObstacles();
            drawEnemies();
            drawBullets();
            drawEnemyBullets();
            drawParticles();
            
            // Only start showing overlay after explosion finishes (200 frames = ~3.3 seconds in slow-mo)
            const explosionDuration = 200;
            
            // Dark overlay - starts after explosion
            if (deathTimer > explosionDuration) {
                const overlayAlpha = Math.min((deathTimer - explosionDuration) / 60, 0.8);
                ctx.fillStyle = `rgba(0, 0, 0, ${overlayAlpha})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // "YOU DIED" text - fade in after overlay starts
            if (deathTimer > explosionDuration + 30) {
                const textAlpha = Math.min((deathTimer - explosionDuration - 30) / 60, 1);
                ctx.globalAlpha = textAlpha;
                ctx.fillStyle = '#ff0000';
                ctx.font = 'bold 96px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('YOU DIED', canvas.width / 2, canvas.height / 3);
                ctx.globalAlpha = 1;
            }
            
            // Stats - appear after "YOU DIED"
            if (deathTimer > explosionDuration + 90) {
                const statsAlpha = Math.min((deathTimer - explosionDuration - 90) / 30, 1);
                ctx.globalAlpha = statsAlpha;
                
                // Money earned
                ctx.fillStyle = '#ffcc00';
                ctx.font = 'bold 32px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`Money Earned: $${deathMoneyCount}`, canvas.width / 2, canvas.height / 2 + 20);
                
                // Enemies killed
                ctx.fillStyle = '#ff6666';
                ctx.fillText(`Enemies Killed: ${deathKillsCount}`, canvas.width / 2, canvas.height / 2 + 70);
                
                // Death penalty message
                ctx.fillStyle = '#ff4444';
                ctx.font = 'bold 28px Arial';
                ctx.fillText(` MONEY LOST: -$${deathMoneyPenalty} (10% penalty)`, canvas.width / 2, canvas.height / 2 + 130);
                
                ctx.globalAlpha = 1;
            }
            
            // Continue button - appears after stats finish counting
            if (deathTimer > explosionDuration + 240 && deathMoneyCount >= runMoneyEarned && deathKillsCount >= runEnemiesKilled) {
                const buttonAlpha = Math.min((deathTimer - explosionDuration - 240) / 30, 1);
                ctx.globalAlpha = buttonAlpha;
                
                const buttonWidth = 200;
                const buttonHeight = 50;
                const buttonX = canvas.width / 2 - buttonWidth / 2;
                const buttonY = canvas.height / 2 + 200;
                
                // Button background
                ctx.fillStyle = continueButtonHover ? '#00aa00' : '#008800';
                ctx.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);
                
                // Button border
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 3;
                ctx.strokeRect(buttonX, buttonY, buttonWidth, buttonHeight);
                
                // Button text
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('CONTINUE', canvas.width / 2, buttonY + buttonHeight / 2);
                
                ctx.globalAlpha = 1;
            }
        }

        // Draw pause overlay
        function drawPauseOverlay() {
            // Semi-transparent overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Pause text
            ctx.fillStyle = '#ffffff';
            ctx.font = '48px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);

            // Instructions
            ctx.font = '24px Arial';
            ctx.fillText('Press ESC to resume', canvas.width / 2, canvas.height / 2 + 50);
        }

        // Draw background
        function drawBackground() {
            // Empty void (dark gray area outside the dungeon floor)
            ctx.fillStyle = '#111111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Walkable dungeon floor
            ctx.fillStyle = '#232323';
            for (let zone of walkableZones) {
                ctx.fillRect(
                    zone.x - camera.x,
                    zone.y - camera.y,
                    zone.width,
                    zone.height
                );
            }

            // Draw map grid pattern with proper state management
            ctx.strokeStyle = '#3a3a3a';
            ctx.lineWidth = 1;
            const gridSize = 100;

            // Draw only over walkable zones
            for (let zone of walkableZones) {
                const zx = zone.x - camera.x;
                const zy = zone.y - camera.y;

                for (let x = zone.x - (zone.x % gridSize); x < zone.x + zone.width; x += gridSize) {
                    const screenX = x - camera.x;
                    if (screenX >= 0 && screenX <= canvas.width) {
                        ctx.beginPath();
                        ctx.moveTo(screenX, zy);
                        ctx.lineTo(screenX, zy + zone.height);
                        ctx.stroke();
                    }
                }

                for (let y = zone.y - (zone.y % gridSize); y < zone.y + zone.height; y += gridSize) {
                    const screenY = y - camera.y;
                    if (screenY >= 0 && screenY <= canvas.height) {
                        ctx.beginPath();
                        ctx.moveTo(zx, screenY);
                        ctx.lineTo(zx + zone.width, screenY);
                        ctx.stroke();
                    }
                }
            }
        }

        // Draw obstacles
        function drawObstacles() {
            ctx.fillStyle = '#ffffff';
            for (let obstacle of obstacles) {
                ctx.fillRect(
                    obstacle.x - camera.x,
                    obstacle.y - camera.y,
                    obstacle.width,
                    obstacle.height
                );
            }
        }

        // Game loop
        function gameLoop() {
            if (gameState === 'death') {
                updateDeathScreen();
                drawDeathScreen();
            } else if (gameState === 'playing') {
                const shakeOffset = updateScreenShake();

                ctx.save();
                ctx.globalAlpha = 1; // Ensure alpha is reset
                ctx.translate(shakeOffset.x, shakeOffset.y);
                drawBackground();
                
                if (!isPaused) {
                    updatePlayer();
                    updateBullets();
                    updateEnemyBullets();
                    updateHitscanEffects();
                    updateParticles();
                    updateNoise();
                    updateDifficulty();
                    spawnEnemies();
                    updateEnemies();
                    updateCoins();
                    // updateExtractDoor(); // DISABLED FOR TESTING
                }
                
                drawPlayer();
                drawBullets();
                drawEnemyBullets();
                drawHitscanEffects();
                drawParticles();
                drawCoins();
                drawEnemies();
                // drawExtractDoor(); // DISABLED FOR TESTING
                
                // Draw lighting effect before obstacles
                drawLightingEffect();

                // Draw obstacles on top so they're always visible
                drawObstacles();

                ctx.restore();
                
                drawDifficultyBar();
                drawMoneyCounter();
                drawHealthBar();

                if (isPaused) {
                    drawPauseOverlay();
                }
            }

            requestAnimationFrame(gameLoop);
        }

        resetRunState();

        // Start game
        gameLoop();
    </script>
</body>
</html>
